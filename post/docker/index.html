<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker | 0opsdc</title><meta name=keywords content="Daily"><meta name=description content="Docker概述 镜像（image）：
一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。 容器（container）：
Docker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。容器可以被启动、开始、停止、删除。每个容器都是相互个隔离的。也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。 仓库（repository）：
仓库是集中存放镜像文件的场所。仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。仓库分为公开仓库和私有仓库两种形式。最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。 Docker安装 环境:CentOS 7
1.官方文档
2.yum安装gcc相关环境：
yum -y install gcc yum -y install gcc-c++ 3.卸载旧版本：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 4.安装依赖包：
yum install -y yum-utils 5.设置镜像仓库：
# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors."><meta name=author content="0opsdc"><link rel=canonical href=https://oopsdc.com/post/docker/><link crossorigin=anonymous href=/assets/css/stylesheet.56b5cc8c8054cf5f30eac4b81af2021f829171098f6e116bb016ed77e3264a36.css integrity="sha256-VrXMjIBUz18w6sS4GvICH4KRcQmPbhFrsBbtd+MmSjY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gitee.com/oopsdc/PicBed/raw/master/oopsdc.tk/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://gitee.com/oopsdc/PicBed/raw/master/oopsdc.tk/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://gitee.com/oopsdc/PicBed/raw/master/oopsdc.tk/favicon.png><link rel=apple-touch-icon href=https://gitee.com/oopsdc/PicBed/raw/master/oopsdc.tk/favicon.png><link rel=mask-icon href=https://gitee.com/oopsdc/PicBed/raw/master/oopsdc.tk/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Docker"><meta property="og:description" content="Docker概述 镜像（image）：
一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。 容器（container）：
Docker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。容器可以被启动、开始、停止、删除。每个容器都是相互个隔离的。也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。 仓库（repository）：
仓库是集中存放镜像文件的场所。仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。仓库分为公开仓库和私有仓库两种形式。最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。 Docker安装 环境:CentOS 7
1.官方文档
2.yum安装gcc相关环境：
yum -y install gcc yum -y install gcc-c++ 3.卸载旧版本：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 4.安装依赖包：
yum install -y yum-utils 5.设置镜像仓库：
# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors."><meta property="og:type" content="article"><meta property="og:url" content="https://oopsdc.com/post/docker/"><meta property="og:image" content="https://oopsdc.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-04-13T22:06:50+08:00"><meta property="article:modified_time" content="2021-04-13T22:06:50+08:00"><meta property="og:site_name" content="0opsdc"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://oopsdc.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Docker"><meta name=twitter:description content="Docker概述 镜像（image）：
一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。 容器（container）：
Docker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。容器可以被启动、开始、停止、删除。每个容器都是相互个隔离的。也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。 仓库（repository）：
仓库是集中存放镜像文件的场所。仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。仓库分为公开仓库和私有仓库两种形式。最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。 Docker安装 环境:CentOS 7
1.官方文档
2.yum安装gcc相关环境：
yum -y install gcc yum -y install gcc-c++ 3.卸载旧版本：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 4.安装依赖包：
yum install -y yum-utils 5.设置镜像仓库：
# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oopsdc.com/post/"},{"@type":"ListItem","position":2,"name":"Docker","item":"https://oopsdc.com/post/docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker","name":"Docker","description":"Docker概述 镜像（image）：\n一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。 容器（container）：\nDocker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。\r容器可以被启动、开始、停止、删除。\r每个容器都是相互个隔离的。\r也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。\r容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。 仓库（repository）：\n仓库是集中存放镜像文件的场所。\r仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。\r仓库分为公开仓库和私有仓库两种形式。\r最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。 Docker安装 环境:CentOS 7\n1.官方文档\n2.yum安装gcc相关环境：\nyum -y install gcc yum -y install gcc-c++ 3.卸载旧版本：\nyum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 4.安装依赖包：\nyum install -y yum-utils 5.设置镜像仓库：\n# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors.","keywords":["Daily"],"articleBody":"Docker概述 镜像（image）：\n一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。 容器（container）：\nDocker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。\r容器可以被启动、开始、停止、删除。\r每个容器都是相互个隔离的。\r也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。\r容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。 仓库（repository）：\n仓库是集中存放镜像文件的场所。\r仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。\r仓库分为公开仓库和私有仓库两种形式。\r最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。 Docker安装 环境:CentOS 7\n1.官方文档\n2.yum安装gcc相关环境：\nyum -y install gcc yum -y install gcc-c++ 3.卸载旧版本：\nyum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 4.安装依赖包：\nyum install -y yum-utils 5.设置镜像仓库：\n# 错误 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo ## 报错 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout # 推荐国内镜像 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 6.更新yum软件包索引：\nyum makecache fast 7.安装Docker CE：\nyum install docker-ce docker-ce-cli containerd.io 8.启动Docker：\nsystemctl start docker 9.测试命令：\ndocker version # 查看Docker版本 docker run hello-world # 拉取镜像 docker images # 查看本地镜像 Docker卸载 systemctl stop docker yum -y remove docker-ce docker-ce-cli containerd.io rm -rf /var/lib/docker Docker换源 # 创建或修改/etc/docker/daemon.json文件 vim /etc/docker/daemon.json { \"registry-mirrors\": [\"https://registry.docker-cn.com\"] } systemctl daemon-reload systemctl restart docker.service # 网易 http://hub-mirror.c.163.com # ustc https://docker.mirrors.ustc.edu.cn # 中国科技大学 https://docker.mirrors.ustc.edu.cn # 阿里云容器 服务 https://cr.console.aliyun.com/ # 首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址，类似于“https://1234abcd.mirror.aliyuncs.com” nginx安装 # 运行时报错 Cannot connect to the Docker daemon at unix:///var/run/docker.sock # 解决方法 systemctl restart docker docker search nginx docker pull nginx docker images docker run -d --name nginx -p 3344:80 nginx docker ps docker stop tomcat安装 docker search tomcat docker pull tomcat docker run -it --rm tomcat:9.0 docker run -d -p 3355:8080 docker exec -it /bin/bash # 问题：1.部分Linux命令无法执行；2.webapps文件夹为空，文件在webapps.dist cp -r webapps.dist/* webapps rm webapps.dist webapps 部署es+kibana # es暴露的端口很多，十分耗内存，数据一般需要放置到安全目录 # 启动es docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:latest # --net somenetwork 网络配置 # 查看CPU状态 docker stats # 运行环境修改 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:latest Portainer安装 Docker图形化管理工具，提供一个后台面板：\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Rancher(CI/CD使用)\nDocker镜像讲解 镜像是什么 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。\n所有应用直接打包Docker镜像。\n如何得到镜像：\n官方下载 朋友分享 自己制作 Docker镜像加载原理 UnionFS(联合文件系统)\n我们下载的时候看见的一层层就是这个。\n是一种分层、轻量级且高性能的文件系统，支持对文件系统的修改作为一次提交来层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directions into a single virtual filesystem)。Union文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。\n特性：一次同时加载多个文件系统，但从外面只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\nDocker镜像加载原理\nDocker的镜像实际上由一层层文件系统组成，这种层级的文件系统称为UnionFS。\nbootfs(boot file system)主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统一样，包含boot加载器和内核。boot加载完成后整个内核都在内存中，此时内存的使用权已转交给内核，此时系统也会卸载bootfs。\nrootfs，在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，如Ubuntu、CentOS等。\n对于一个精简的OS，rootfs可以很小，只需包含最基本的命令、工具和程序库即可，因为底层直接用Host的kernel，自己只需提供rootfs。可见对于不同的Linux发行版，bootfs基本一致，rootfs会有差别，因此不同的发行版可以公用bootfs。\n分层理解 为什么Docker镜像采用分层结构？\n资源共享，如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份Base镜像，内存中也只需加载一份Base镜像，这样就可以为所有的容器服务了，且镜像的每一层都可以被共享。\n使用docker image inspect查看镜像分层。\n特点\nDocker镜像一般都是只读的，当容器启动时，一个新的可写层被加载到镜像顶部。\n这一层就是我们常说的容器层，容器之下的都叫镜像层。\ncommit镜像 docker commit #提交容器成为一个新的版本 # 命令和git原理类似 docker commit -m=\"description\" -a=\"author\" id target_image_name:[TAG] 实战测试\ndocker run -it -p 8080:8080 tomcat # 将webapps.dist所有文件拷贝到webapps cp -r webapps.dist/* webapps # 将修改后的容器通过commit提交为一个新的镜像 docker commit -a=\"dc\" -m=\"add webapps\" id name:version 容器 容器就是通过docker镜像创建的实例对象，常用命令如下:\ndocker ps # 查看运行中的容器状态 docker ps -a # 查看所有容器状态 docker ps -aq # 列出所有容器ID docker stop $(docker ps -aq) # 停止所有容器 docker rm $(docker ps -aq) # 删除所有容器 docker rmi $(docker images -q) # 删除所有镜像 容器数据卷 什么是容器数据卷？ Docker的理念：将应用和环境打包成一个镜像。\n如果数据都在容器中，容器一删除则数据消失。\n需求：数据持久化。\n容器之间需要有一个数据共享技术。\nDocker容器中产生的数据同步到本地。\n这就是卷技术，目录挂载，将容器内目录挂载到虚拟机或Linux中。\n总结：容器的持久化和同步操作。容器间也可以数据共享。\n使用数据卷 使用命令挂载\ndocker run -it -v 主机内目录:容器内目录 docker run -it -v /home/test_real:/home centos /bin/bash # 宿主机查看挂载状态 docker inspect container-id \"Mounts\": [ { \"Type\": \"bind\", \"Source\": \"/home/test_real\", \"Destination\": \"/home\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"rprivate\" } ] # 退出容器 exit # 修改文件内容 vim testfile # 重新打开容器 docker start container-id # 进入容器 docker attach container-id #未start报错:You cannot attach to a stopped container, start it first MySQL安装 思考：MySQL数据持久化问题。\n# 拉取MySQL docker pull mysql # 官方启动:docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag # 运行容器并做数据挂载 docker run -d -p 3310:3306 -v /home/mysql_real/conf:/etc/mysql/conf.d -v /home/mysql_real/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql 具名和匿名挂载 # 匿名挂载 -v 容器内路径 docker run -d -P --name name -v /etc/nginx nginx # -P:随机映射端口 # 查看所有的volume情况 docker volume ls # 具名挂载 docker run -d -P --name name -v juming-nginx:/etc/nginx nginx 所有Docker容器内的卷，没有指定目录的情况下都在/var/lib/docker/volumes/xxx/_data。\n通过具名挂载可以方便的找到我们的一个卷，大多数情况使用具名挂载。\n# 如何确定匿名挂载还是具名挂载，还是指定路径挂载 -v 容器内路径 # 匿名挂载 -v 卷名:容器内路径 # 具名挂载 -v /宿主机路径:容器内路径 # 指定路径挂载 拓展：\n# 通过-v容器内路径:ro/rw改变读写权限 docker run -d -P --name name -v juming-nginx:/etc/nginx:ro nginx # 只能通过宿主机操作，容器内部无法操作 docker run -d -P --name name -v juming-nginx:/etc/nginx:rw nginx 初识Dockerfile Dockerfile就是用来构建Docker镜像的构建文件。其实就是命令脚本，通过这个脚本可以生成镜像。\n镜像是一层层的，脚本就是一个个的命令，每个命令就是一层。\n# 创建一个dockerfile文件 # 指令(大写) 参数 FROM centos VOLUME[\"volume01\",\"volume02\"] # 匿名挂载，和外部一定有一个同步目录 CMD echo \"-----end-----\" CMD /bin/bash # 使用 docker build -f dockerfile1 -t dc/centos . # 查看容器本地卷信息，测试文件是否同步 docker inspect -f \"{{.Monuts}}\" id 这种方式使用十分多，因为我们通常会构建自己的镜像。\n假设构建镜像的时候没有挂载卷，要手动镜像挂载，-v 卷名:容器内路径。\n数据卷容器 多个MySQL实现数据共享。\ndocker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql 容器之间配置信息的传递，数据卷容器的生命周期一直持续到无人使用为止。\n一旦持久化到了本地，这个时候本地数据不会删除。\nDockerFile 核心是用来构建Docker镜像的文件。是一个命令参数脚本。\n构建步骤：\n编写一个Dockerfile文件 docker build构建成为一个镜像 docker run运行镜像 docker push发布镜像(DockerHub、阿里云镜像仓库) DockerFile构建过程 基础知识：\n每个保留关键字(指令)都必须为大写字母 执行顺序由上至下 #为注释 每个指令都会创建提交一个新镜像层并提交 DockerFile面向开发。\nDockerFile：构建文件，定义了一切的步骤，源代码。\nDockerImage：通过DockerFile构建生成的镜像，最终发布和运行的产品。\nDocker容器：镜像运行起来提供服务。\nDockerFile指令 命令 讲解 FROM 构建一切的基础镜像 MAINTAINER 镜像作者，name+email RUN 镜像构建时运行的命令 ADD 添加服务压缩包 WORKDIR 镜像工作目录 VOLUME 挂载目录位置 EXPOSE 保留端口配置 CMD 指定容器启动时运行的命令，只有最后一条命令生效，命令可被替代 ENTRYPOINT 同CMD，可以追加命令 ONBUILD 当构建一个被继承DockerFile时会触发ONBUILD COPY 类似ADD，将文件拷贝到镜像中 ENV 构建时设置环境变量 实战centos部署 DockerHub大部分镜像都是由基础镜像scratch组成，然后配置需要的软件和配置。\n# 1.编写DockerFile文件 FROM centos MAINTAINER dc\u003c1107762686@qq.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"-----end-----\" CMD /bin/bash # 2.通过文件构建镜像 docker build -f mydockerfile -t mycentos:1.0 . # 运行结果 Successfully built b8fab89ecdea Successfully tagged mycentos:1.0 # 3.测试运行 docker run -it mycentos:1.0 # 列出本地进行的变更历史 docker history image-id CMD 和 ENTRYPOINT 的区别\nCMD\t# 指定容器启动时要运行的命令，只有最后一个生效，且可被替代 ENTRYPOINT\t# 同CMD，可以追加命令 测试CMD\n# 编写DockerFile文件 vim dockerfile-cmd-test FROM centos CMD [\"ls\",\"-a\"] # 构建镜像 docker build -f dockerfile-cmd-test -t cmd-test . # RUN运行，发现`ls -a`命令生效 docker run `id` # 想追加一个命令 ls -al docker run `id` -l # error # cmd清理 -l 替换了CMD [\"ls\",\"-a\"]命令，-l不是命令所以报错 测试ENTRYPOINT\n# 编写DockerFile文件 vim dockerfile-cmd-entrypoint FROM centos ENTRYPOINT [\"ls\",\"-a\"] # 构建镜像 docker build -f dockerfile-cmd-entrypoint -t entrypoint-test . DockerFile中很多命令都相似，我们需要了解其中的区别，最好的学习就是对比并测试。\n实战tomcat部署 准备镜像文件，tomcat压缩包，jdk压缩包 编写DockerFile文件，官方命名Dockerfile，build会自动寻找这个文件，不需要-f指定： FROM centos MAINTAINER dc\u003c1107762686@qq.com\u003e COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.22.tar.gz /usr/local ADD jdk-8u281-linux-x64.tar.gz /usr/local RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk-8u281 ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.22/bin/logs/catalina.out 3.构建镜像：\ndocker build -t diy-tomcat . 4.启动镜像：\ndocker run -d -p 9090:8080 --name dc-tomcat -v /home/tomcat/test:/url/local/apache-tomcat-9.0.22/webapps/test -v /home/tomcat/tomcat-logs/:/usr/local/apache-tomcat-9.0.22/logs diy-tomcat 5.进入容器：\ndocker exec -it `随意复制一段id` /bin/bash 6.访问测试：\ncurl localhost:9090 7.发布项目(做了卷挂载，直接在本地发布即可)\nxml文件 jsp文件 项目部署成功。\n发布镜像 DockerHub\n1.登录DockerHub：Docker Hub：\ndocker login -u username -p password 2.在服务器上提交镜像：\ndocker tag [image-id/image-name:tag] new-image-name:tag docker push image-id:tag/image-name:tag aliyun镜像\n1.登录阿里云：阿里云-上云就上阿里云 (aliyun.com)\n2.进入容器镜像服务:容器镜像服务_镜像构建_镜像授权_镜像托管-阿里云 (aliyun.com)\n3.创建命名空间\n4.创建容器镜像\n5.参考官方文档\nDocker网络 Docker0 问题：docker是如何处理容器网络访问的？\n我们首先创建一个tomcat容器，利用学到的两类方法来试试。\n方式一，手动执行\ndocker run -d -P --name tomcat-01 tomcat docker exec -it tomcat-01 ip addr 方式二，编写DockerFile\n# DockerFile内容 FROM tomcat MAINTAINER dc\u003c1107762686@qq.com\u003e CMD docker run -d -P --name tomcat-01 tomcat CMD docker exec -it tomcat-01 ip addr # 构建镜像 docker build -f dockerfile -t tomcat-test . 方法有误，稍后修改。\n容器启动的时候会得到一个docker分配的eth@if262ip地址。\n测试：Linux能ping通容器内部ip地址。\n原理\n每安装并启动一个Docker容器，Docker就会给其分配一个ip，只要安装了Docker，就会有一个docker0网卡。\ndocker0网卡使用桥接模式，使用veth-pair技术。\n再启动一个容器就会多一对网卡。\n7: veth4f1ae6f@if6 docker exec -it tomcat-02 ping `ip` #tomcat-02可以ping通tomcat-01 # 容器之间可以互通 小结\nDocker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥。\nDocker中所有的网络接口都是虚拟的，转发效率高。\n容器删除，则对应的一对网桥也被回收。\n–link 思考场景\n编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉，如何进行处理？\ndocker exec -it tomcat-02 ping tomcat-01 # 无法直接ping通 # 启动一个tomcat-03，并与tomcat-02连接 docker run -d -P --name tomcat-03 --link tomcat-02 tomcat # 实现通过名称ping通，但是反向无法ping通 # 其实就是tomcat-03在本地配置了tomcat-02 # 查看tomcat-03 hosts配置 docker exec -it tomcat-03 cat /etc/hosts --link就是在hosts配置中增加了一个映射，已经不建议使用。\ndocker0问题：不支持容器名进行连接访问。\n自定义网络 # 查看所有docker网络 docker network ls 网络模式\n参数 说明 bridge 桥接模式 none 不配置网络 host 和主机共享网络 container 容器网络连通（局限很大，实际使用较少） # --net bridge 为默认参数 docker run -d -P --name tomcat-01 --net bridge tomcat # docker0特点：默认不能通过名称访问，通过 --link 打通连接 # 可以自定义一个网络 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet # 查看网络概览 docker network ls # 查看详细信息 docker network inspect mynet # 使用自己的网络 docker run -d -P --name tomcat-mynet-01 --net mynet tomcat docker run -d -P --name tomcat-mynet-02 --net mynet tomcat # ping测试 docker exec -it tomcat-mynet-01 ping tomcat-mynet-02 # 两者互相可ping通 优点：\nredis、mysql：不同集群使用不同网络，保证集群是安全和健康的。\n网络连通 # 启动两个容器 docker run -d -P --name tomcat-01 tomcat docker run -d -P --name tomcat-02 tomcat # 已知tomcat-01与tomcat-02无法ping通 # 连接网络 docker network connect mynet tomcat-01 docker network connect mynet tomcat-02 # 查看 mynet docker network inspect mynet # 其中包含了tomcat-01与tomcat-02 # 四个容器完美ping通 实战Redis集群部署 # 使用脚本部署 docker network create redis --subnet 172.42.0.0/16 # 通过脚本创建六个redis配置 for port in $(seq 1 6); do mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.42.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} -v /mydata/redis/node-${port}/data:/data -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.42.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; # 1-6依次修改即可 docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.42.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf # 进入容器 docker exec -it redis-1 /bin/sh # redis中为sh # 创建集群 redis-cli --cluster create 172.42.0.11:6379 172.42.0.12:6379 172.42.0.13:6379 172.42.0.14:6379 172.42.0.15:6379 172.42.0.16:6379 --cluster-replicas 1 # 查看集群数量 redis-cli -c cluster info cluster nodes set a b get a # 第一次get会提示`Could not connect to Redis at 172.42.0.13:6379: Host is unreachable` # 重新进入 redis-cli -c get a # `Redirected to slot [15495] located at 172.42.0.14:6379 \"b\"` cluster nodes `redis-3状态为master,fail，redis-4状态为myself,master` SpringBoot微服务打包Docker镜像 构建SpringBoot项目 打包应用 编写DockerFile 构建镜像 发布运行 # DockerFile FROM java:8 COPY *.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] # 构建 docker build -t image-name . Docker Compose 概述 官方概述:Overview of Docker Compose | Docker Documentation\n轻松高效管理容器，定义运行多个容器。\n一键启动/停止服务。\n三步骤 1.Define your app’s environment with a Dockerfile so it can be reproduced anywhere.\nDockerfile 保证我们的项目在任何地方可以运行 2.Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment.\nservices 什么是服务 docker-compose.yml 文件应该怎么写 3.Run docker-compose up and Compose starts and runs your entire app.\n启动项目 作用：批量容器编排\n理解\nCompose 是 Docker 官方开源项目，需要安装。\nDockerfile让程序在任何地方运行。\nversion: '2.0' services: web: build: . ports: - \"5000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} docker-compose up 100个服务\nCompose重要的两个概念：\n服务 services，容器、应用(web、redis、mysql…) 项目 project，一组关联容器 安装Docker Compose 官方安装文档:Install Docker Compose | Docker Documentation\n1.下载\n# 官方下载，从GitHub下载，巨慢 sudo curl -L \"https://github.com/docker/compose/releases/download/1.28.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose # 国内镜像 curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` \u003e /usr/local/bin/docker-compose # 查看是否下载成功 cd /usr/local/bin ls 2.授权\nchmod +x /usr/local/bin/docker-compose # 或 chmod 777 /usr/local/bin/docker-compose # 任意位置运行 docerk-compose version 查看是否成功 初使用 使用教程：Get started with Docker Compose | Docker Documentation\n1.创建项目文件夹\n2.项目文件夹下创建app.py文件，将官网代码复制过来：\nimport time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) 3.创建requirements.txt依赖包文件\n4.创建Dockerfile：\nFROM python:3.7-alpine\t# 基本环境包 WORKDIR /code\t# 工作目录 ENV FLASK_APP=app.py\t# 环境 ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers\t# 运行 COPY requirements.txt requirements.txt\t# 拷贝文件 RUN pip install -r requirements.txt\t# 使用pip安装 EXPOSE 5000\t# 暴露端口 COPY . .\t# 拷贝当前目录 CMD [\"flask\", \"run\"]\t# 运行 5.在Compose文件中定义服务：\n# 以前我们需要docker run逐个运行 # 现在创建docker-compose.yml文件 version: \"3.9\"\t# 版本 services:\t# 服务 web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 6.使用Compose构建并运行应用：\ndocker-compose up # docker-compose up -d 后台运行 # 我这里报错了，报错如下： ERROR: Version in \"./docker-compose.yml\" is unsupported. You might be seeing this error because you're using the wrong Compose file version. Either specify a supported version (e.g \"2.2\" or \"3.3\") and place your service definitions under the `services` key, or omit the `version` key and place your service definitions at the root of the file to use version 1. For more on the Compose file format versions, see https://docs.docker.com/compose/compose-file/ # 解决方案，修改docker-compose.yml文件中的版本 version: \"3.9\" -\u003e version: \"3.3\" # 项目部署过程中出现了其它错误 docker-compose build # 先build一下 docker-compose up # 成功启动 # 测试，每访问一次计数器+1 localhost:5000 # 浏览器键入 curl localhost:5000 # curl请求 7.停止：\n# 在yaml文件所在目录下运行命令 docker-compose stop Ctrl+C 流程：\n1.创建网络\n2.执行Docker-compose.yml\n3.启动服务\n默认规则：\n自动拉取镜像：\n[root@localhost ~]# docker service ls Error response from daemon: This node is not a swarm manager. Use \"docker swarm init\" or \"docker swarm join\" to connect this node to swarm and try again. **命名规则：**默认服务名 文件名_服务名_num。A B _num 副本数量。集群状态下不可能只有一个运行实例。弹性：10 HA 高可用、高并发。kunectl service负载均衡。\n**网络规则：**使用命令docker network ls查看，默认名称composetest_default。项目中的内容都在同一网络，可通过域名访问。\n小结：\n1.应用，如app.py\n2.Dockerfile应用打包为镜像\n3.Docker-compose.yml文件(定义整个服务、需要的环境)。完整的上线服务\n4.启动compose项目(docker-compose up)\nyaml规则 官方示例:Compose file version 3 reference | Docker Documentation\ndocker-compose.yml是核心。\n# 只有三层 version: '' # 版本 services: # 服务 服务1: web # 服务配置 images build network ... 服务2: redis ... # 其他配置 网络/卷/全局规则 volumes: networks: configs: depends_on\nSimple example：\nversion: \"3.9\" services: web: build: . depends_on:\t# 依赖于db和redis - db - redis redis: image: redis db: image: postgres # 启动顺序：web --\u003e redis --\u003e db There are several things to be aware of when using depends_on:\ndepends_on does not wait for db and redis to be “ready” before starting web - only until they have been started. If you need to wait for a service to be ready, see Controlling startup order for more on this problem and strategies for solving it. Version 3 no longer supports the condition form of depends_on. The depends_on option is ignored when deploying a stack in swarm mode with a version 3 Compose file. deploy\nAdded in version 3 file format.\nSpecify configuration related to the deployment and running of services. This only takes effect when deploying to a swarm with docker stack deploy, and is ignored by docker-compose up and docker-compose run.\nversion: \"3.9\" services: redis: image: redis:alpine deploy: replicas: 6\t# 副本 placement: max_replicas_per_node: 1 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure 部署wp博客 官方文档部署WordPress博客:Quickstart: Compose and WordPress | Docker Documentation\n1.创建一个空文件夹，此处命名为my_wordpress\nmkdir my_wordpress 2.切换到对应目录\ncd my_wordpress/ 3.创建docker-compose.yml文件\nversion: \"3.3\" services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} Notes:\nThe docker volume db_data persists any updates made by WordPress to the database. Learn more about docker volumes WordPress Multisite works only on ports 80 and 443. 4.构建项目\nNow, run docker-compose up -d from your project directory.\nThis runs docker-compose up in detached mode, pulls the needed Docker images, and starts the wordpress and database containers.\n$ docker-compose up -d Note: WordPress Multisite works only on ports 80 and/or 443. If you get an error message about binding 0.0.0.0 to port 80 or 443 (depending on which one you specified), it is likely that the port you configured for WordPress is already in use by another service.\n5.开始安装\n经过第4步后，访问localhost:8000端口即可设置博客。\n实战 1.编写项目微服务\n2.Dockefile构建镜像\n3.docker-compose.yaml编排项目\n4.docker-compose up\n5.docker-compose up --build项目重新部署打包\nDocker Swarm Docker Swarm官方文档:Swarm mode overview | Docker Documentation\n节点如何工作： Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.\nThere are two types of nodes: managers and workers.\nIf you haven’t already, read through the swarm mode overview and key concepts.\n管理与工作节点 管理节点 Manager nodes handle cluster management tasks:\nmaintaining cluster state scheduling services serving swarm mode HTTP API endpoints Using a Raft implementation, the managers maintain a consistent internal state of the entire swarm and all the services running on it. For testing purposes it is OK to run a swarm with a single manager. If the manager in a single-manager swarm fails, your services continue to run, but you need to create a new cluster to recover.\nTo take advantage of swarm mode’s fault-tolerance features, Docker recommends you implement an odd number of nodes according to your organization’s high-availability requirements. When you have multiple managers you can recover from the failure of a manager node without downtime.\nA three-manager swarm tolerates a maximum loss of one manager.\nA five-manager swarm tolerates a maximum simultaneous loss of two manager nodes.\nAn N manager cluster tolerates the loss of at most (N-1)/2 managers.\nDocker recommends a maximum of seven manager nodes for a swarm.\nImportant Note: Adding more managers does NOT mean increased scalability or higher performance. In general, the opposite is true.\n工作节点 Worker nodes are also instances of Docker Engine whose sole purpose is to execute containers. Worker nodes don’t participate in the Raft distributed state, make scheduling decisions, or serve the swarm mode HTTP API.\nYou can create a swarm of one manager node, but you cannot have a worker node without at least one manager node. By default, all managers are also workers. In a single manager node cluster, you can run commands like docker service create and the scheduler places all tasks on the local Engine.\nTo prevent the scheduler from placing tasks on a manager node in a multi-node swarm, set the availability for the manager node to Drain. The scheduler gracefully stops tasks on nodes in Drain mode and schedules the tasks on an Active node. The scheduler does not assign new tasks to nodes with Drain availability.\nRefer to the docker node update command line reference to see how to change node availability.\nRaft 图中有一个Raft Consensus Group的概念，我们来查阅一下资料。\nRaft:一种新的分布式协议研究，为真实世界应用建立的协议，主要注重协议落地性和可理解性。保证大多数节点存活才可使用。\n关于分布式系统的Raft算法讲解:分布式系统的Raft算法 - 解道Jdon\nRaft算法详解:图解：什么是Raft算法？ - 无敌码龙的个人空间 - OSCHINA - 中文开源技术交流社区\n命令 # 帮助命令 docker swarm --help Usage: docker swarm COMMAND Manage Swarm Commands: ca Display and rotate the root CA init Initialize a swarm join Join a swarm as a node and/or manager join-token Manage join tokens leave Leave the swarm unlock Unlock swarm unlock-key Manage the unlock key update Update the swarm docker swarm init\t# 初始化节点 docker swarm join\t# 加入节点 # 获取令牌 docker swarm join-token manager docker swarm join-token worker docker node ls # 查看节点 具体使用 服务无感升级为灰度发布(也称金丝雀发布)。\ndocker run\t# 容器启动，不具有扩缩容功能 docker service 服务\t# 能实现扩缩容及滚动更新 docker service create -p 8888:80 --name my-nginx nginx # 查看服务 docker service ps my-nginx docker service ls docker service inspect my-nginx # 创建副本 docker service update --replicas 3 my-nginx docker service update --replicas 1 my-nginx # 更新为1个服务 docker service scale my-nginx=5\t# 动态扩缩容，与update效果相同 docker service rm my-nginx 概念总结 Swarm 集群的管理和编号。docker可以初始化一个swarm集群，其它节点可以加入。(manager、worker)\nNode 就是一个docker节点，多个节点组成一个网络集群。\nService 任务，可以在manager或worker来运行。用户访问的其实就是service，这是集群的核心。\nTask 容器内命令，细节任务。\n调整service运行方式 docker service create --mode replicated --name my-centos centos\t# 仅在副本运行 docker service create --mode global --name haha alpine ping baidu.com\t# 全局运行 拓展 网络模式：“PublishMode”:“ingress”\nSwarm:\nOverlay:网络变成一个整体\ningress:具有负载均衡功能的特殊Overlay网络，\nDocker Stack docker-compose\t# 单机部署项目 docker-compose up -d wordpress.yaml docker stack\t# 集群部署 docker stack deploy wordpress.yaml Docker Secret Commands: create Create a secret from a file or STDIN as content inspect Display detailed information on one or more secrets ls List secrets rm Remove one or more secrets Docker Config Commands:\rcreate Create a config from a file or STDIN\rinspect Display detailed information on one or more configs\rls List configs\rrm Remove one or more configs 文章许可：本文采用CC BY-NC-SA 4.0许可协议，转载请注明出处。\n","wordCount":"2854","inLanguage":"en","datePublished":"2021-04-13T22:06:50+08:00","dateModified":"2021-04-13T22:06:50+08:00","author":{"@type":"Person","name":"0opsdc"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://oopsdc.com/post/docker/"},"publisher":{"@type":"Organization","name":"0opsdc","logo":{"@type":"ImageObject","url":"https://gitee.com/oopsdc/PicBed/raw/master/oopsdc.tk/favicon.png"}}}</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oopsdc.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://oopsdc.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://oopsdc.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://oopsdc.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://oopsdc.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://oopsdc.com/>Home</a>&nbsp;»&nbsp;<a href=https://oopsdc.com/post/>Posts</a></div><h1 class=post-title>Docker</h1><div class=post-meta>Created:&nbsp;<span title='2021-04-13 22:06:50 +0800 CST'>2021-04-13</span>&nbsp;·&nbsp;Updated:&nbsp;2021-04-13&nbsp;·&nbsp;0opsdc<div class=meta-item>&nbsp·&nbsp
        <span id=busuanzi_container_page_pv>Article Views: <span id=busuanzi_value_page_pv></span> times</span></div></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#docker%e6%a6%82%e8%bf%b0 aria-label=Docker概述>Docker概述</a></li><li><a href=#docker%e5%ae%89%e8%a3%85 aria-label=Docker安装>Docker安装</a></li><li><a href=#docker%e5%8d%b8%e8%bd%bd aria-label=Docker卸载>Docker卸载</a></li><li><a href=#docker%e6%8d%a2%e6%ba%90 aria-label=Docker换源>Docker换源</a></li><li><a href=#nginx%e5%ae%89%e8%a3%85 aria-label=nginx安装>nginx安装</a></li><li><a href=#tomcat%e5%ae%89%e8%a3%85 aria-label=tomcat安装>tomcat安装</a></li><li><a href=#%e9%83%a8%e7%bd%b2eskibana aria-label=部署es+kibana>部署es+kibana</a></li><li><a href=#portainer%e5%ae%89%e8%a3%85 aria-label=Portainer安装>Portainer安装</a></li><li><a href=#docker%e9%95%9c%e5%83%8f%e8%ae%b2%e8%a7%a3 aria-label=Docker镜像讲解>Docker镜像讲解</a><ul><li><a href=#%e9%95%9c%e5%83%8f%e6%98%af%e4%bb%80%e4%b9%88 aria-label=镜像是什么>镜像是什么</a></li><li><a href=#docker%e9%95%9c%e5%83%8f%e5%8a%a0%e8%bd%bd%e5%8e%9f%e7%90%86 aria-label=Docker镜像加载原理>Docker镜像加载原理</a></li><li><a href=#%e5%88%86%e5%b1%82%e7%90%86%e8%a7%a3 aria-label=分层理解>分层理解</a></li><li><a href=#commit%e9%95%9c%e5%83%8f aria-label=commit镜像>commit镜像</a></li></ul></li><li><a href=#%e5%ae%b9%e5%99%a8 aria-label=容器>容器</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e6%95%b0%e6%8d%ae%e5%8d%b7 aria-label=容器数据卷>容器数据卷</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%b9%e5%99%a8%e6%95%b0%e6%8d%ae%e5%8d%b7 aria-label=什么是容器数据卷？>什么是容器数据卷？</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%95%b0%e6%8d%ae%e5%8d%b7 aria-label=使用数据卷>使用数据卷</a></li><li><a href=#mysql%e5%ae%89%e8%a3%85 aria-label=MySQL安装>MySQL安装</a></li><li><a href=#%e5%85%b7%e5%90%8d%e5%92%8c%e5%8c%bf%e5%90%8d%e6%8c%82%e8%bd%bd aria-label=具名和匿名挂载>具名和匿名挂载</a></li><li><a href=#%e5%88%9d%e8%af%86dockerfile aria-label=初识Dockerfile>初识Dockerfile</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%8d%b7%e5%ae%b9%e5%99%a8 aria-label=数据卷容器>数据卷容器</a></li></ul></li><li><a href=#dockerfile aria-label=DockerFile>DockerFile</a><ul><li><a href=#dockerfile%e6%9e%84%e5%bb%ba%e8%bf%87%e7%a8%8b aria-label=DockerFile构建过程>DockerFile构建过程</a></li><li><a href=#dockerfile%e6%8c%87%e4%bb%a4 aria-label=DockerFile指令>DockerFile指令</a></li><li><a href=#%e5%ae%9e%e6%88%98centos%e9%83%a8%e7%bd%b2 aria-label=实战centos部署>实战centos部署</a></li><li><a href=#%e5%ae%9e%e6%88%98tomcat%e9%83%a8%e7%bd%b2 aria-label=实战tomcat部署>实战tomcat部署</a></li><li><a href=#%e5%8f%91%e5%b8%83%e9%95%9c%e5%83%8f aria-label=发布镜像>发布镜像</a></li></ul></li><li><a href=#docker%e7%bd%91%e7%bb%9c aria-label=Docker网络>Docker网络</a><ul><li><a href=#docker0 aria-label=Docker0>Docker0</a></li><li><a href=#--link aria-label=&amp;ndash;link>&ndash;link</a></li><li><a href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bd%91%e7%bb%9c aria-label=自定义网络>自定义网络</a></li><li><a href=#%e7%bd%91%e7%bb%9c%e8%bf%9e%e9%80%9a aria-label=网络连通>网络连通</a></li><li><a href=#%e5%ae%9e%e6%88%98redis%e9%9b%86%e7%be%a4%e9%83%a8%e7%bd%b2 aria-label=实战Redis集群部署>实战Redis集群部署</a></li><li><a href=#springboot%e5%be%ae%e6%9c%8d%e5%8a%a1%e6%89%93%e5%8c%85docker%e9%95%9c%e5%83%8f aria-label=SpringBoot微服务打包Docker镜像>SpringBoot微服务打包Docker镜像</a></li></ul></li><li><a href=#docker-compose aria-label="Docker Compose">Docker Compose</a><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#%e4%b8%89%e6%ad%a5%e9%aa%a4 aria-label=三步骤>三步骤</a></li><li><a href=#%e5%ae%89%e8%a3%85docker-compose aria-label="安装Docker Compose">安装Docker Compose</a></li><li><a href=#%e5%88%9d%e4%bd%bf%e7%94%a8 aria-label=初使用>初使用</a></li><li><a href=#yaml%e8%a7%84%e5%88%99 aria-label=yaml规则>yaml规则</a></li><li><a href=#%e9%83%a8%e7%bd%b2wp%e5%8d%9a%e5%ae%a2 aria-label=部署wp博客>部署wp博客</a></li><li><a href=#%e5%ae%9e%e6%88%98 aria-label=实战>实战</a></li></ul></li><li><a href=#docker-swarm aria-label="Docker Swarm">Docker Swarm</a><ul><li><a href=#%e8%8a%82%e7%82%b9%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c aria-label=节点如何工作：>节点如何工作：</a></li><li><a href=#%e7%ae%a1%e7%90%86%e4%b8%8e%e5%b7%a5%e4%bd%9c%e8%8a%82%e7%82%b9 aria-label=管理与工作节点>管理与工作节点</a><ul><li><a href=#%e7%ae%a1%e7%90%86%e8%8a%82%e7%82%b9 aria-label=管理节点>管理节点</a></li><li><a href=#%e5%b7%a5%e4%bd%9c%e8%8a%82%e7%82%b9 aria-label=工作节点>工作节点</a></li></ul></li><li><a href=#raft aria-label=Raft>Raft</a></li><li><a href=#%e5%91%bd%e4%bb%a4 aria-label=命令>命令</a></li><li><a href=#%e5%85%b7%e4%bd%93%e4%bd%bf%e7%94%a8 aria-label=具体使用>具体使用</a></li><li><a href=#%e6%a6%82%e5%bf%b5%e6%80%bb%e7%bb%93 aria-label=概念总结>概念总结</a><ul><li><a href=#swarm aria-label=Swarm>Swarm</a></li><li><a href=#node aria-label=Node>Node</a></li><li><a href=#service aria-label=Service>Service</a></li><li><a href=#task aria-label=Task>Task</a></li><li><a href=#%e8%b0%83%e6%95%b4service%e8%bf%90%e8%a1%8c%e6%96%b9%e5%bc%8f aria-label=调整service运行方式>调整service运行方式</a></li><li><a href=#%e6%8b%93%e5%b1%95 aria-label=拓展>拓展</a></li></ul></li></ul></li><li><a href=#docker-stack aria-label="Docker Stack">Docker Stack</a></li><li><a href=#docker-secret aria-label="Docker Secret">Docker Secret</a></li><li><a href=#docker-config aria-label="Docker Config">Docker Config</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=docker概述>Docker概述<a hidden class=anchor aria-hidden=true href=#docker概述>#</a></h1><p>镜像（<code>image</code>）：</p><pre tabindex=0><code>一个只读模板。一个镜像可以用来创建多个Docker容器，好似Java中的类和对象，镜像是类，容器是对象。
</code></pre><p>容器（<code>container</code>）：</p><pre tabindex=0><code>Docker利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。
容器可以被启动、开始、停止、删除。
每个容器都是相互个隔离的。
也可以把容器看做一个简易版Linux环境(包括root用户权限、进程空间、用户空间和网络空间等)及运行在其中的应用程序。
容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器最上面一层可读可写。
</code></pre><p>仓库（<code>repository</code>）：</p><pre tabindex=0><code>仓库是集中存放镜像文件的场所。
仓库和仓库注册服务器(registry)是有区别的，后者往往存在多个仓库，每个仓库又存在多个镜像，每个镜像有不同的标签。
仓库分为公开仓库和私有仓库两种形式。
最大的公开仓库是Docker Hub，国内最大的为阿里云、网易云等。
</code></pre><h1 id=docker安装>Docker安装<a hidden class=anchor aria-hidden=true href=#docker安装>#</a></h1><blockquote><p>环境:CentOS 7</p></blockquote><p>1.<a href=https://docs.docker.com/engine/install/centos/>官方文档</a></p><p>2.<code>yum</code>安装<code>gcc</code>相关环境：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>yum -y install gcc
</span></span><span style=display:flex><span>yum -y install gcc-c++
</span></span></code></pre></div><p>3.卸载旧版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>yum remove docker <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>					docker-client <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>					docker-client-latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>					docker-common <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>					docker-latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>					docker-latest-logrotate <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>					docker-logrotate <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>					docker-engine
</span></span></code></pre></div><p>4.安装依赖包：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>yum install -y yum-utils
</span></span></code></pre></div><p>5.设置镜像仓库：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 错误</span>
</span></span><span style=display:flex><span>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</span></span><span style=display:flex><span><span style=color:#75715e>## 报错</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Errno 14<span style=color:#f92672>]</span> curl#35 - TCP connection reset by peer
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Errno 12<span style=color:#f92672>]</span> curl#35 - Timeout
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 推荐国内镜像</span>
</span></span><span style=display:flex><span>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</span></span></code></pre></div><p>6.更新<code>yum</code>软件包索引：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>yum makecache fast
</span></span></code></pre></div><p>7.安装<code>Docker CE</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>yum install docker-ce docker-ce-cli containerd.io
</span></span></code></pre></div><p>8.启动<code>Docker</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>systemctl start docker
</span></span></code></pre></div><p>9.测试命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker version <span style=color:#75715e># 查看Docker版本</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker run hello-world <span style=color:#75715e># 拉取镜像</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker images <span style=color:#75715e># 查看本地镜像</span>
</span></span></code></pre></div><h1 id=docker卸载>Docker卸载<a hidden class=anchor aria-hidden=true href=#docker卸载>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl stop docker
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>yum -y remove docker-ce docker-ce-cli containerd.io
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rm -rf /var/lib/docker
</span></span></code></pre></div><h1 id=docker换源>Docker换源<a hidden class=anchor aria-hidden=true href=#docker换源>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 创建或修改/etc/docker/daemon.json文件</span>
</span></span><span style=display:flex><span>vim /etc/docker/daemon.json
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;registry-mirrors&#34;</span>: <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;https://registry.docker-cn.com&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>systemctl daemon-reload
</span></span><span style=display:flex><span>systemctl restart docker.service
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 网易 http://hub-mirror.c.163.com</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ustc https://docker.mirrors.ustc.edu.cn</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 中国科技大学 https://docker.mirrors.ustc.edu.cn</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 阿里云容器 服务 https://cr.console.aliyun.com/</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址，类似于“https://1234abcd.mirror.aliyuncs.com”</span>
</span></span></code></pre></div><h1 id=nginx安装>nginx安装<a hidden class=anchor aria-hidden=true href=#nginx安装>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 运行时报错</span>
</span></span><span style=display:flex><span>Cannot connect to the Docker daemon at unix:///var/run/docker.sock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 解决方法</span>
</span></span><span style=display:flex><span>systemctl restart docker
</span></span><span style=display:flex><span>docker search nginx
</span></span><span style=display:flex><span>docker pull nginx
</span></span><span style=display:flex><span>docker images
</span></span><span style=display:flex><span>docker run -d --name nginx -p 3344:80 nginx
</span></span><span style=display:flex><span>docker ps
</span></span><span style=display:flex><span>docker stop &lt;container-id&gt;
</span></span></code></pre></div><h1 id=tomcat安装>tomcat安装<a hidden class=anchor aria-hidden=true href=#tomcat安装>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker search tomcat
</span></span><span style=display:flex><span>docker pull tomcat
</span></span><span style=display:flex><span>docker run -it --rm tomcat:9.0
</span></span><span style=display:flex><span>docker run -d -p 3355:8080
</span></span><span style=display:flex><span>docker exec -it &lt;container-id&gt; /bin/bash
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 问题：1.部分Linux命令无法执行；2.webapps文件夹为空，文件在webapps.dist</span>
</span></span><span style=display:flex><span>cp -r webapps.dist/* webapps
</span></span><span style=display:flex><span>rm webapps.dist webapps
</span></span></code></pre></div><h1 id=部署eskibana>部署es+kibana<a hidden class=anchor aria-hidden=true href=#部署eskibana>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># es暴露的端口很多，十分耗内存，数据一般需要放置到安全目录</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动es</span>
</span></span><span style=display:flex><span>docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e <span style=color:#e6db74>&#34;discovery.type=single-node&#34;</span> elasticsearch:latest
</span></span><span style=display:flex><span><span style=color:#75715e># --net somenetwork 网络配置</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看CPU状态</span>
</span></span><span style=display:flex><span>docker stats
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 运行环境修改</span>
</span></span><span style=display:flex><span>docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e <span style=color:#e6db74>&#34;discovery.type=single-node&#34;</span> -e ES_JAVA_OPTS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-Xms64m -Xmx512m&#34;</span> elasticsearch:latest
</span></span></code></pre></div><h1 id=portainer安装>Portainer安装<a hidden class=anchor aria-hidden=true href=#portainer安装>#</a></h1><p><code>Docker</code>图形化管理工具，提供一个后台面板：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -d -p 8088:9000 --restart<span style=color:#f92672>=</span>always -v /var/run/docker.sock:/var/run/docker.sock --privileged<span style=color:#f92672>=</span>true portainer/portainer
</span></span></code></pre></div><p><code>Rancher</code>(<code>CI/CD</code>使用)</p><h1 id=docker镜像讲解>Docker镜像讲解<a hidden class=anchor aria-hidden=true href=#docker镜像讲解>#</a></h1><h2 id=镜像是什么>镜像是什么<a hidden class=anchor aria-hidden=true href=#镜像是什么>#</a></h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p>所有应用直接打包<code>Docker</code>镜像。</p><p>如何得到镜像：</p><ul><li>官方下载</li><li>朋友分享</li><li>自己制作</li></ul><h2 id=docker镜像加载原理>Docker镜像加载原理<a hidden class=anchor aria-hidden=true href=#docker镜像加载原理>#</a></h2><blockquote><p>UnionFS(联合文件系统)</p></blockquote><p>我们下载的时候看见的一层层就是这个。</p><p>是一种分层、轻量级且高性能的文件系统，支持对文件系统的修改作为一次提交来层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directions into a single virtual filesystem)。<code>Union</code>文件系统是<code>Docker</code>镜像的基础，镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><blockquote><p>Docker镜像加载原理</p></blockquote><p><code>Docker</code>的镜像实际上由一层层文件系统组成，这种层级的文件系统称为<code>UnionFS</code>。</p><p><code>bootfs</code>(boot file system)主要包含<code>bootloader</code>和<code>kernel</code>，<code>bootloader</code>主要引导加载<code>kernel</code>，<code>Linux</code>刚启动时会加载<code>bootfs</code>文件系统，在<code>Docker</code>镜像的最底层是<code>bootfs</code>。这一层与我们典型的<code>Linux/Unix</code>系统一样，包含<code>boot</code>加载器和内核。<code>boot</code>加载完成后整个内核都在内存中，此时内存的使用权已转交给内核，此时系统也会卸载<code>bootfs</code>。</p><p><code>rootfs</code>，在<code>bootfs</code>之上。包含的就是典型<code>Linux</code>系统中的<code>/dev</code>，<code>/proc</code>，<code>/bin</code>，<code>/etc</code>等标准目录和文件。<code>rootfs</code>就是各种不同的操作系统发行版，如<code>Ubuntu</code>、<code>CentOS</code>等。</p><p>对于一个精简的<code>OS</code>，<code>rootfs</code>可以很小，只需包含最基本的命令、工具和程序库即可，因为底层直接用<code>Host</code>的<code>kernel</code>，自己只需提供<code>rootfs</code>。可见对于不同的<code>Linux</code>发行版，<code>bootfs</code>基本一致，<code>rootfs</code>会有差别，因此不同的发行版可以公用<code>bootfs</code>。</p><h2 id=分层理解>分层理解<a hidden class=anchor aria-hidden=true href=#分层理解>#</a></h2><p>为什么<code>Docker</code>镜像采用分层结构？</p><p>资源共享，如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份<code>Base</code>镜像，内存中也只需加载一份<code>Base</code>镜像，这样就可以为所有的容器服务了，且镜像的每一层都可以被共享。</p><p>使用<code>docker image inspect</code>查看镜像分层。</p><blockquote><p>特点</p></blockquote><p><code>Docker</code>镜像一般都是只读的，当容器启动时，一个新的可写层被加载到镜像顶部。</p><p>这一层就是我们常说的容器层，容器之下的都叫镜像层。</p><h2 id=commit镜像>commit镜像<a hidden class=anchor aria-hidden=true href=#commit镜像>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker commit <span style=color:#75715e>#提交容器成为一个新的版本</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 命令和git原理类似</span>
</span></span><span style=display:flex><span>docker commit -m<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;description&#34;</span> -a<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;author&#34;</span> id target_image_name:<span style=color:#f92672>[</span>TAG<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>实战测试</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -it -p 8080:8080 tomcat
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将webapps.dist所有文件拷贝到webapps</span>
</span></span><span style=display:flex><span>cp -r webapps.dist/* webapps
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将修改后的容器通过commit提交为一个新的镜像</span>
</span></span><span style=display:flex><span>docker commit -a<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dc&#34;</span> -m<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;add webapps&#34;</span> id name:version
</span></span></code></pre></div><h1 id=容器>容器<a hidden class=anchor aria-hidden=true href=#容器>#</a></h1><p>容器就是通过<code>docker</code>镜像创建的实例对象，常用命令如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker ps <span style=color:#75715e># 查看运行中的容器状态</span>
</span></span><span style=display:flex><span>docker ps -a <span style=color:#75715e># 查看所有容器状态</span>
</span></span><span style=display:flex><span>docker ps -aq <span style=color:#75715e># 列出所有容器ID</span>
</span></span><span style=display:flex><span>docker stop <span style=color:#66d9ef>$(</span>docker ps -aq<span style=color:#66d9ef>)</span> <span style=color:#75715e># 停止所有容器</span>
</span></span><span style=display:flex><span>docker rm <span style=color:#66d9ef>$(</span>docker ps -aq<span style=color:#66d9ef>)</span> <span style=color:#75715e># 删除所有容器</span>
</span></span><span style=display:flex><span>docker rmi <span style=color:#66d9ef>$(</span>docker images -q<span style=color:#66d9ef>)</span> <span style=color:#75715e># 删除所有镜像</span>
</span></span></code></pre></div><h1 id=容器数据卷>容器数据卷<a hidden class=anchor aria-hidden=true href=#容器数据卷>#</a></h1><h2 id=什么是容器数据卷>什么是容器数据卷？<a hidden class=anchor aria-hidden=true href=#什么是容器数据卷>#</a></h2><p><code>Docker</code>的理念：将应用和环境打包成一个镜像。</p><p>如果数据都在容器中，容器一删除则数据消失。</p><p>需求：数据持久化。</p><p>容器之间需要有一个数据共享技术。</p><p><code>Docker</code>容器中产生的数据同步到本地。</p><p>这就是卷技术，目录挂载，将容器内目录挂载到虚拟机或<code>Linux</code>中。</p><p>总结：容器的持久化和同步操作。容器间也可以数据共享。</p><h2 id=使用数据卷>使用数据卷<a hidden class=anchor aria-hidden=true href=#使用数据卷>#</a></h2><blockquote><p>使用命令挂载</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -it -v 主机内目录:容器内目录
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker run -it -v /home/test_real:/home centos /bin/bash
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 宿主机查看挂载状态</span>
</span></span><span style=display:flex><span>docker inspect container-id
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Mounts&#34;</span>: <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Type&#34;</span>: <span style=color:#e6db74>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Source&#34;</span>: <span style=color:#e6db74>&#34;/home/test_real&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Destination&#34;</span>: <span style=color:#e6db74>&#34;/home&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Mode&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;RW&#34;</span>: true,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Propagation&#34;</span>: <span style=color:#e6db74>&#34;rprivate&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=color:#75715e># 退出容器</span>
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 修改文件内容</span>
</span></span><span style=display:flex><span>vim testfile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 重新打开容器</span>
</span></span><span style=display:flex><span>docker start container-id
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 进入容器</span>
</span></span><span style=display:flex><span>docker attach container-id <span style=color:#75715e>#未start报错:You cannot attach to a stopped container, start it first</span>
</span></span></code></pre></div><h2 id=mysql安装>MySQL安装<a hidden class=anchor aria-hidden=true href=#mysql安装>#</a></h2><p>思考：<code>MySQL</code>数据持久化问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 拉取MySQL</span>
</span></span><span style=display:flex><span>docker pull mysql
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 官方启动:docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 运行容器并做数据挂载</span>
</span></span><span style=display:flex><span>docker run -d -p 3310:3306 -v /home/mysql_real/conf:/etc/mysql/conf.d -v /home/mysql_real/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span><span style=color:#ae81ff>123456</span> mysql
</span></span></code></pre></div><h2 id=具名和匿名挂载>具名和匿名挂载<a hidden class=anchor aria-hidden=true href=#具名和匿名挂载>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># 匿名挂载</span>
</span></span><span style=display:flex><span>-v 容器内路径
</span></span><span style=display:flex><span>docker run -d -P --name name -v /etc/nginx nginx <span style=color:#75715e># -P:随机映射端口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看所有的volume情况</span>
</span></span><span style=display:flex><span>docker volume ls
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 具名挂载</span>
</span></span><span style=display:flex><span>docker run -d -P --name name -v juming-nginx:/etc/nginx nginx
</span></span></code></pre></div><p>所有<code>Docker</code>容器内的卷，没有指定目录的情况下都在<code>/var/lib/docker/volumes/xxx/_data</code>。</p><p>通过具名挂载可以方便的找到我们的一个卷，大多数情况使用<code>具名挂载</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 如何确定匿名挂载还是具名挂载，还是指定路径挂载</span>
</span></span><span style=display:flex><span>-v 容器内路径 <span style=color:#75715e># 匿名挂载</span>
</span></span><span style=display:flex><span>-v 卷名:容器内路径 <span style=color:#75715e># 具名挂载</span>
</span></span><span style=display:flex><span>-v /宿主机路径:容器内路径 <span style=color:#75715e># 指定路径挂载</span>
</span></span></code></pre></div><p>拓展：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 通过-v容器内路径:ro/rw改变读写权限</span>
</span></span><span style=display:flex><span>docker run -d -P --name name -v juming-nginx:/etc/nginx:ro nginx <span style=color:#75715e># 只能通过宿主机操作，容器内部无法操作</span>
</span></span><span style=display:flex><span>docker run -d -P --name name -v juming-nginx:/etc/nginx:rw nginx
</span></span></code></pre></div><h2 id=初识dockerfile>初识Dockerfile<a hidden class=anchor aria-hidden=true href=#初识dockerfile>#</a></h2><p><code>Dockerfile</code>就是用来构建<code>Docker</code>镜像的构建文件。其实就是命令脚本，通过这个脚本可以生成镜像。</p><p>镜像是一层层的，脚本就是一个个的命令，每个命令就是一层。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 创建一个dockerfile文件</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 指令(大写) 参数</span>
</span></span><span style=display:flex><span>FROM centos
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>VOLUME<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;volume01&#34;</span>,<span style=color:#e6db74>&#34;volume02&#34;</span><span style=color:#f92672>]</span> <span style=color:#75715e># 匿名挂载，和外部一定有一个同步目录</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CMD echo <span style=color:#e6db74>&#34;-----end-----&#34;</span>
</span></span><span style=display:flex><span>CMD /bin/bash
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用</span>
</span></span><span style=display:flex><span>docker build -f dockerfile1 -t dc/centos .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看容器本地卷信息，测试文件是否同步</span>
</span></span><span style=display:flex><span>docker inspect -f <span style=color:#e6db74>&#34;{{.Monuts}}&#34;</span> id
</span></span></code></pre></div><p>这种方式使用十分多，因为我们通常会构建自己的镜像。</p><p>假设构建镜像的时候没有挂载卷，要手动镜像挂载，<code>-v 卷名:容器内路径</code>。</p><h2 id=数据卷容器>数据卷容器<a hidden class=anchor aria-hidden=true href=#数据卷容器>#</a></h2><p>多个<code>MySQL</code>实现数据共享。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span><span style=color:#ae81ff>123456</span> --name mysql01 mysql
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span><span style=color:#ae81ff>123456</span> --name mysql02 --volumes-from mysql01 mysql
</span></span></code></pre></div><p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到无人使用为止。</p><p>一旦持久化到了本地，这个时候本地数据不会删除。</p><h1 id=dockerfile>DockerFile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h1><p>核心是用来构建<code>Docker</code>镜像的文件。是一个命令参数脚本。</p><p>构建步骤：</p><ol><li>编写一个<code>Dockerfile</code>文件</li><li><code>docker build</code>构建成为一个镜像</li><li><code>docker run</code>运行镜像</li><li><code>docker push</code>发布镜像(DockerHub、阿里云镜像仓库)</li></ol><h2 id=dockerfile构建过程>DockerFile构建过程<a hidden class=anchor aria-hidden=true href=#dockerfile构建过程>#</a></h2><p><strong>基础知识</strong>：</p><ol><li>每个保留关键字(指令)都必须为大写字母</li><li>执行顺序由上至下</li><li><code>#</code>为注释</li><li>每个指令都会创建提交一个新镜像层并提交</li></ol><p><code>DockerFile</code>面向开发。</p><p><code>DockerFile</code>：构建文件，定义了一切的步骤，源代码。</p><p><code>DockerImage</code>：通过DockerFile构建生成的镜像，最终发布和运行的产品。</p><p><code>Docker</code>容器：镜像运行起来提供服务。</p><h2 id=dockerfile指令>DockerFile指令<a hidden class=anchor aria-hidden=true href=#dockerfile指令>#</a></h2><table><thead><tr><th style=text-align:center>命令</th><th style=text-align:center>讲解</th></tr></thead><tbody><tr><td style=text-align:center>FROM</td><td style=text-align:center>构建一切的基础镜像</td></tr><tr><td style=text-align:center>MAINTAINER</td><td style=text-align:center>镜像作者，name+email</td></tr><tr><td style=text-align:center>RUN</td><td style=text-align:center>镜像构建时运行的命令</td></tr><tr><td style=text-align:center>ADD</td><td style=text-align:center>添加服务压缩包</td></tr><tr><td style=text-align:center>WORKDIR</td><td style=text-align:center>镜像工作目录</td></tr><tr><td style=text-align:center>VOLUME</td><td style=text-align:center>挂载目录位置</td></tr><tr><td style=text-align:center>EXPOSE</td><td style=text-align:center>保留端口配置</td></tr><tr><td style=text-align:center>CMD</td><td style=text-align:center>指定容器启动时运行的命令，只有最后一条命令生效，命令可被替代</td></tr><tr><td style=text-align:center>ENTRYPOINT</td><td style=text-align:center>同CMD，可以追加命令</td></tr><tr><td style=text-align:center>ONBUILD</td><td style=text-align:center>当构建一个被继承DockerFile时会触发ONBUILD</td></tr><tr><td style=text-align:center>COPY</td><td style=text-align:center>类似ADD，将文件拷贝到镜像中</td></tr><tr><td style=text-align:center>ENV</td><td style=text-align:center>构建时设置环境变量</td></tr></tbody></table><h2 id=实战centos部署>实战centos部署<a hidden class=anchor aria-hidden=true href=#实战centos部署>#</a></h2><p><code>DockerHub</code>大部分镜像都是由基础镜像<code>scratch</code>组成，然后配置需要的软件和配置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 1.编写DockerFile文件</span>
</span></span><span style=display:flex><span>FROM centos
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MAINTAINER dc&lt;1107762686@qq.com&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENV MYPATH /usr/local
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>WORKDIR $MYPATH
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>RUN yum -y install vim
</span></span><span style=display:flex><span>RUN yum -y install net-tools
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>EXPOSE <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CMD echo $MYPATH
</span></span><span style=display:flex><span>CMD echo <span style=color:#e6db74>&#34;-----end-----&#34;</span>
</span></span><span style=display:flex><span>CMD /bin/bash
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2.通过文件构建镜像</span>
</span></span><span style=display:flex><span>docker build -f mydockerfile -t mycentos:1.0 .
</span></span><span style=display:flex><span><span style=color:#75715e># 运行结果</span>
</span></span><span style=display:flex><span>Successfully built b8fab89ecdea
</span></span><span style=display:flex><span>Successfully tagged mycentos:1.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3.测试运行</span>
</span></span><span style=display:flex><span>docker run -it mycentos:1.0
</span></span><span style=display:flex><span><span style=color:#75715e># 列出本地进行的变更历史</span>
</span></span><span style=display:flex><span>docker history image-id
</span></span></code></pre></div><blockquote><p>CMD 和 ENTRYPOINT 的区别</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>CMD					<span style=color:#75715e># 指定容器启动时要运行的命令，只有最后一个生效，且可被替代</span>
</span></span><span style=display:flex><span>ENTRYPOINT			<span style=color:#75715e># 同CMD，可以追加命令</span>
</span></span></code></pre></div><p>测试<code>CMD</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 编写DockerFile文件</span>
</span></span><span style=display:flex><span>vim dockerfile-cmd-test
</span></span><span style=display:flex><span>FROM centos
</span></span><span style=display:flex><span>CMD <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;ls&#34;</span>,<span style=color:#e6db74>&#34;-a&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 构建镜像</span>
</span></span><span style=display:flex><span>docker build -f dockerfile-cmd-test -t cmd-test .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># RUN运行，发现`ls -a`命令生效</span>
</span></span><span style=display:flex><span>docker run <span style=color:#e6db74>`</span>id<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 想追加一个命令 ls -al</span>
</span></span><span style=display:flex><span>docker run <span style=color:#e6db74>`</span>id<span style=color:#e6db74>`</span> -l <span style=color:#75715e># error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># cmd清理 -l 替换了CMD [&#34;ls&#34;,&#34;-a&#34;]命令，-l不是命令所以报错</span>
</span></span></code></pre></div><p>测试<code>ENTRYPOINT</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 编写DockerFile文件</span>
</span></span><span style=display:flex><span>vim dockerfile-cmd-entrypoint
</span></span><span style=display:flex><span>FROM centos
</span></span><span style=display:flex><span>ENTRYPOINT <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;ls&#34;</span>,<span style=color:#e6db74>&#34;-a&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 构建镜像</span>
</span></span><span style=display:flex><span>docker build -f dockerfile-cmd-entrypoint -t entrypoint-test .
</span></span></code></pre></div><p><code>DockerFile</code>中很多命令都相似，我们需要了解其中的区别，最好的学习就是对比并测试。</p><h2 id=实战tomcat部署>实战tomcat部署<a hidden class=anchor aria-hidden=true href=#实战tomcat部署>#</a></h2><ol><li>准备镜像文件，<code>tomcat</code>压缩包，<code>jdk</code>压缩包</li><li>编写<code>DockerFile</code>文件，官方命名<code>Dockerfile</code>，<code>build</code>会自动寻找这个文件，不需要<code>-f</code>指定：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>FROM centos
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MAINTAINER dc&lt;1107762686@qq.com&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>COPY readme.txt /usr/local/readme.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ADD apache-tomcat-9.0.22.tar.gz /usr/local
</span></span><span style=display:flex><span>ADD jdk-8u281-linux-x64.tar.gz /usr/local
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>RUN yum -y install vim
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENV MYPATH /usr/local
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>WORKDIR $MYPATH
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENV JAVA_HOME /usr/local/jdk-8u281
</span></span><span style=display:flex><span>ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
</span></span><span style=display:flex><span>ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22
</span></span><span style=display:flex><span>ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22
</span></span><span style=display:flex><span>ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>EXPOSE <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh <span style=color:#f92672>&amp;&amp;</span> tail -F /usr/local/apache-tomcat-9.0.22/bin/logs/catalina.out
</span></span></code></pre></div><p>3.构建镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build -t diy-tomcat .
</span></span></code></pre></div><p>4.启动镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -d -p 9090:8080 --name dc-tomcat -v /home/tomcat/test:/url/local/apache-tomcat-9.0.22/webapps/test -v /home/tomcat/tomcat-logs/:/usr/local/apache-tomcat-9.0.22/logs diy-tomcat
</span></span></code></pre></div><p>5.进入容器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker exec -it <span style=color:#e6db74>`</span>随意复制一段id<span style=color:#e6db74>`</span> /bin/bash
</span></span></code></pre></div><p>6.访问测试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl localhost:9090
</span></span></code></pre></div><p>7.发布项目(做了卷挂载，直接在本地发布即可)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>xml文件
</span></span><span style=display:flex><span>jsp文件
</span></span></code></pre></div><p>项目部署成功。</p><h2 id=发布镜像>发布镜像<a hidden class=anchor aria-hidden=true href=#发布镜像>#</a></h2><blockquote><p>DockerHub</p></blockquote><p>1.登录<code>DockerHub</code>：<a href=https://hub.docker.com/>Docker Hub</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker login -u username -p password
</span></span></code></pre></div><p>2.在服务器上提交镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker tag <span style=color:#f92672>[</span>image-id/image-name:tag<span style=color:#f92672>]</span> new-image-name:tag
</span></span><span style=display:flex><span>docker push image-id:tag/image-name:tag
</span></span></code></pre></div><blockquote><p>aliyun镜像</p></blockquote><p>1.登录阿里云：<a href=https://www.aliyun.com/>阿里云-上云就上阿里云 (aliyun.com)</a></p><p>2.进入容器镜像服务:<a href="https://www.aliyun.com/product/acr?spm=5176.10695662.1362911.1.48573417z7IhcP">容器镜像服务_镜像构建_镜像授权_镜像托管-阿里云 (aliyun.com)</a></p><p>3.创建命名空间</p><p>4.创建容器镜像</p><p>5.参考官方文档</p><h1 id=docker网络>Docker网络<a hidden class=anchor aria-hidden=true href=#docker网络>#</a></h1><h2 id=docker0>Docker0<a hidden class=anchor aria-hidden=true href=#docker0>#</a></h2><p>问题：<code>docker</code>是如何处理容器网络访问的？</p><p>我们首先创建一个<code>tomcat</code>容器，利用学到的两类方法来试试。</p><blockquote><p>方式一，手动执行</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -d -P --name tomcat-01 tomcat
</span></span><span style=display:flex><span>docker exec -it tomcat-01 ip addr
</span></span></code></pre></div><blockquote><p>方式二，编写<code>DockerFile</code></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># DockerFile内容</span>
</span></span><span style=display:flex><span>FROM tomcat
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MAINTAINER dc&lt;1107762686@qq.com&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CMD docker run -d -P --name tomcat-01 tomcat
</span></span><span style=display:flex><span>CMD docker exec -it tomcat-01 ip addr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 构建镜像</span>
</span></span><span style=display:flex><span>docker build -f dockerfile -t tomcat-test .
</span></span></code></pre></div><p><del>方法有误，稍后修改。</del></p><p>容器启动的时候会得到一个<code>docker</code>分配的<code>eth@if262</code>ip地址。</p><p>测试：<code>Linux</code>能<code>ping</code>通容器内部ip地址。</p><blockquote><p>原理</p></blockquote><p>每安装并启动一个<code>Docker</code>容器，<code>Docker</code>就会给其分配一个<code>ip</code>，只要安装了<code>Docker</code>，就会有一个<code>docker0</code>网卡。</p><p><code>docker0</code>网卡使用桥接模式，使用<code>veth-pair</code>技术。</p><p>再启动一个容器就会多一对网卡。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>7: veth4f1ae6f@if6
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker exec -it tomcat-02 ping <span style=color:#e6db74>`</span>ip<span style=color:#e6db74>`</span> <span style=color:#75715e>#tomcat-02可以ping通tomcat-01</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 容器之间可以互通</span>
</span></span></code></pre></div><blockquote><p>小结</p></blockquote><p><code>Docker</code>使用的是<code>Linux</code>的桥接，宿主机中是一个<code>Docker</code>容器的网桥。</p><p><code>Docker</code>中所有的网络接口都是虚拟的，转发效率高。</p><p>容器删除，则对应的一对网桥也被回收。</p><h2 id=--link>&ndash;link<a hidden class=anchor aria-hidden=true href=#--link>#</a></h2><blockquote><p>思考场景</p></blockquote><p>编写了一个微服务，<code>database url=ip:</code>，项目不重启，数据库<code>ip</code>换掉，如何进行处理？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker exec -it tomcat-02 ping tomcat-01 <span style=color:#75715e># 无法直接ping通</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动一个tomcat-03，并与tomcat-02连接</span>
</span></span><span style=display:flex><span>docker run -d -P --name tomcat-03 --link tomcat-02 tomcat
</span></span><span style=display:flex><span><span style=color:#75715e># 实现通过名称ping通，但是反向无法ping通</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 其实就是tomcat-03在本地配置了tomcat-02</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看tomcat-03 hosts配置</span>
</span></span><span style=display:flex><span>docker exec -it tomcat-03 cat /etc/hosts
</span></span></code></pre></div><p><code>--link</code>就是在<code>hosts</code>配置中增加了一个映射，已经不建议使用。</p><p><code>docker0</code>问题：不支持容器名进行连接访问。</p><h2 id=自定义网络>自定义网络<a hidden class=anchor aria-hidden=true href=#自定义网络>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 查看所有docker网络</span>
</span></span><span style=display:flex><span>docker network ls
</span></span></code></pre></div><p><strong>网络模式</strong></p><table><thead><tr><th style=text-align:center>参数</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td style=text-align:center>bridge</td><td style=text-align:center>桥接模式</td></tr><tr><td style=text-align:center>none</td><td style=text-align:center>不配置网络</td></tr><tr><td style=text-align:center>host</td><td style=text-align:center>和主机共享网络</td></tr><tr><td style=text-align:center>container</td><td style=text-align:center>容器网络连通（局限很大，实际使用较少）</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># --net bridge 为默认参数</span>
</span></span><span style=display:flex><span>docker run -d -P --name tomcat-01 --net bridge tomcat
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># docker0特点：默认不能通过名称访问，通过 --link 打通连接</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 可以自定义一个网络</span>
</span></span><span style=display:flex><span>docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看网络概览</span>
</span></span><span style=display:flex><span>docker network ls
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看详细信息</span>
</span></span><span style=display:flex><span>docker network inspect mynet
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用自己的网络</span>
</span></span><span style=display:flex><span>docker run -d -P --name tomcat-mynet-01 --net mynet tomcat
</span></span><span style=display:flex><span>docker run -d -P --name tomcat-mynet-02 --net mynet tomcat
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ping测试</span>
</span></span><span style=display:flex><span>docker exec -it tomcat-mynet-01 ping tomcat-mynet-02
</span></span><span style=display:flex><span><span style=color:#75715e># 两者互相可ping通</span>
</span></span></code></pre></div><p><strong>优点</strong>：</p><p><code>redis</code>、<code>mysql</code>：不同集群使用不同网络，保证集群是安全和健康的。</p><h2 id=网络连通>网络连通<a hidden class=anchor aria-hidden=true href=#网络连通>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 启动两个容器</span>
</span></span><span style=display:flex><span>docker run -d -P --name tomcat-01 tomcat
</span></span><span style=display:flex><span>docker run -d -P --name tomcat-02 tomcat
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 已知tomcat-01与tomcat-02无法ping通</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 连接网络</span>
</span></span><span style=display:flex><span>docker network connect mynet tomcat-01
</span></span><span style=display:flex><span>docker network connect mynet tomcat-02
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看 mynet</span>
</span></span><span style=display:flex><span>docker network inspect mynet
</span></span><span style=display:flex><span><span style=color:#75715e># 其中包含了tomcat-01与tomcat-02</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 四个容器完美ping通</span>
</span></span></code></pre></div><h2 id=实战redis集群部署>实战Redis集群部署<a hidden class=anchor aria-hidden=true href=#实战redis集群部署>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 使用脚本部署</span>
</span></span><span style=display:flex><span>docker network create redis --subnet 172.42.0.0/16
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 通过脚本创建六个redis配置</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> port in <span style=color:#66d9ef>$(</span>seq <span style=color:#ae81ff>1</span> 6<span style=color:#66d9ef>)</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>mkdir -p /mydata/redis/node-<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/conf
</span></span><span style=display:flex><span>touch /mydata/redis/node-<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/conf/redis.conf
</span></span><span style=display:flex><span>cat <span style=color:#e6db74>&lt;&lt; EOF &gt;/mydata/redis/node-${port}/conf/redis.conf
</span></span></span><span style=display:flex><span><span style=color:#e6db74>port 6379
</span></span></span><span style=display:flex><span><span style=color:#e6db74>bind 0.0.0.0
</span></span></span><span style=display:flex><span><span style=color:#e6db74>cluster-enabled yes
</span></span></span><span style=display:flex><span><span style=color:#e6db74>cluster-config-file nodes.conf
</span></span></span><span style=display:flex><span><span style=color:#e6db74>cluster-node-timeout 5000
</span></span></span><span style=display:flex><span><span style=color:#e6db74>cluster-announce-ip 172.42.0.1${port}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>cluster-announce-port 6379
</span></span></span><span style=display:flex><span><span style=color:#e6db74>cluster-announce-bus-port 16379
</span></span></span><span style=display:flex><span><span style=color:#e6db74>appendonly yes
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker run -p 637<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>:6379 -p 1637<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>:16379 --name redis-<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>-v /mydata/redis/node-<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/data:/data
</span></span><span style=display:flex><span>-v /mydata/redis/node-<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span>/conf/redis.conf:/etc/redis/redis.conf
</span></span><span style=display:flex><span>-d --net redis --ip 172.42.0.1<span style=color:#e6db74>${</span>port<span style=color:#e6db74>}</span> redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1-6依次修改即可</span>
</span></span><span style=display:flex><span>docker run -p 6371:6379 -p 16371:16379 --name redis-1 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-v /mydata/redis/node-1/data:/data <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-d --net redis --ip 172.42.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 进入容器</span>
</span></span><span style=display:flex><span>docker exec -it redis-1 /bin/sh <span style=color:#75715e># redis中为sh</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建集群</span>
</span></span><span style=display:flex><span>redis-cli --cluster create 172.42.0.11:6379 172.42.0.12:6379 172.42.0.13:6379 172.42.0.14:6379 172.42.0.15:6379 172.42.0.16:6379 --cluster-replicas <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看集群数量</span>
</span></span><span style=display:flex><span>redis-cli -c
</span></span><span style=display:flex><span>cluster info
</span></span><span style=display:flex><span>cluster nodes
</span></span><span style=display:flex><span>set a b
</span></span><span style=display:flex><span>get a <span style=color:#75715e># 第一次get会提示`Could not connect to Redis at 172.42.0.13:6379: Host is unreachable`</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 重新进入</span>
</span></span><span style=display:flex><span>redis-cli -c
</span></span><span style=display:flex><span>get a 
</span></span><span style=display:flex><span><span style=color:#75715e># `Redirected to slot [15495] located at 172.42.0.14:6379</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;b&#34;</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cluster nodes
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>redis-3状态为master,fail，redis-4状态为myself,master<span style=color:#e6db74>`</span>
</span></span></code></pre></div><h2 id=springboot微服务打包docker镜像>SpringBoot微服务打包Docker镜像<a hidden class=anchor aria-hidden=true href=#springboot微服务打包docker镜像>#</a></h2><ol><li>构建<code>SpringBoot</code>项目</li><li>打包应用</li><li>编写<code>DockerFile</code></li><li>构建镜像</li><li>发布运行</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># DockerFile</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>FROM java:8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>COPY *.jar /app.jar</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>CMD [&#34;--server.port=8080&#34;]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>EXPOSE 8080</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>ENTRYPOINT [&#34;java&#34;,&#34;-jar&#34;,&#34;/app.jar&#34;]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 构建</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>docker build -t image-name .</span>
</span></span></code></pre></div><h1 id=docker-compose>Docker Compose<a hidden class=anchor aria-hidden=true href=#docker-compose>#</a></h1><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><p>官方概述:<a href=https://docs.docker.com/compose/>Overview of Docker Compose | Docker Documentation</a></p><p>轻松高效管理容器，定义运行多个容器。</p><p>一键启动/停止服务。</p><h2 id=三步骤>三步骤<a hidden class=anchor aria-hidden=true href=#三步骤>#</a></h2><p>1.Define your app&rsquo;s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</p><ul><li>Dockerfile 保证我们的项目在任何地方可以运行</li></ul><p>2.Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</p><ul><li>services 什么是服务</li><li>docker-compose.yml 文件应该怎么写</li></ul><p>3.Run <code>docker-compose up</code> and Compose starts and runs your entire app.</p><ul><li>启动项目</li></ul><p><strong>作用：批量容器编排</strong></p><blockquote><p>理解</p></blockquote><p><code>Compose </code>是 <code>Docker </code>官方开源项目，需要安装。</p><p><code>Dockerfile</code>让程序在任何地方运行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;2.0&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>		- <span style=color:#e6db74>&#34;5000:5000&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>		- <span style=color:#ae81ff>.:/code</span>
</span></span><span style=display:flex><span>		- <span style=color:#ae81ff>logvolume01:/var/log</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>links</span>:
</span></span><span style=display:flex><span>		- <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>logvolume01</span>: {}
</span></span></code></pre></div><p>docker-compose up 100个服务</p><p><strong>Compose重要的两个概念</strong>：</p><ul><li>服务 services，容器、应用(web、redis、mysql&mldr;)</li><li>项目 project，一组关联容器</li></ul><h2 id=安装docker-compose>安装Docker Compose<a hidden class=anchor aria-hidden=true href=#安装docker-compose>#</a></h2><p>官方安装文档:<a href=https://docs.docker.com/compose/install/>Install Docker Compose | Docker Documentation</a></p><p>1.下载</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 官方下载，从GitHub下载，巨慢</span>
</span></span><span style=display:flex><span>sudo curl -L <span style=color:#e6db74>&#34;https://github.com/docker/compose/releases/download/1.28.5/docker-compose-</span><span style=color:#66d9ef>$(</span>uname -s<span style=color:#66d9ef>)</span><span style=color:#e6db74>-</span><span style=color:#66d9ef>$(</span>uname -m<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> -o /usr/local/bin/docker-compose
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 国内镜像</span>
</span></span><span style=display:flex><span>curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-<span style=color:#e6db74>`</span>uname -s<span style=color:#e6db74>`</span>-<span style=color:#e6db74>`</span>uname -m<span style=color:#e6db74>`</span> &gt; /usr/local/bin/docker-compose
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看是否下载成功</span>
</span></span><span style=display:flex><span>cd /usr/local/bin
</span></span><span style=display:flex><span>ls
</span></span></code></pre></div><p>2.授权</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>chmod +x /usr/local/bin/docker-compose
</span></span><span style=display:flex><span><span style=color:#75715e># 或</span>
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>777</span> /usr/local/bin/docker-compose
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 任意位置运行 docerk-compose version 查看是否成功</span>
</span></span></code></pre></div><h2 id=初使用>初使用<a hidden class=anchor aria-hidden=true href=#初使用>#</a></h2><p>使用教程：<a href=https://docs.docker.com/compose/gettingstarted/>Get started with Docker Compose | Docker Documentation</a></p><p>1.创建项目文件夹</p><p>2.项目文件夹下创建<code>app.py</code>文件，将官网代码复制过来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> redis
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> flask <span style=color:#f92672>import</span> Flask
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> Flask(__name__)
</span></span><span style=display:flex><span>cache <span style=color:#f92672>=</span> redis<span style=color:#f92672>.</span>Redis(host<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;redis&#39;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>6379</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_hit_count</span>():
</span></span><span style=display:flex><span>    retries <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> cache<span style=color:#f92672>.</span>incr(<span style=color:#e6db74>&#39;hits&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> redis<span style=color:#f92672>.</span>exceptions<span style=color:#f92672>.</span>ConnectionError <span style=color:#66d9ef>as</span> exc:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> retries <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>raise</span> exc
</span></span><span style=display:flex><span>            retries <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>route(<span style=color:#e6db74>&#39;/&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hello</span>():
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> get_hit_count()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;Hello World! I have been seen </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> times.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(count)
</span></span></code></pre></div><p>3.创建<code>requirements.txt</code>依赖包文件</p><p>4.创建<code>Dockerfile</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>FROM python:3.7-alpine									<span style=color:#75715e># 基本环境包</span>
</span></span><span style=display:flex><span>WORKDIR /code											<span style=color:#75715e># 工作目录</span>
</span></span><span style=display:flex><span>ENV FLASK_APP<span style=color:#f92672>=</span>app.py									<span style=color:#75715e># 环境</span>
</span></span><span style=display:flex><span>ENV FLASK_RUN_HOST<span style=color:#f92672>=</span>0.0.0.0
</span></span><span style=display:flex><span>RUN apk add --no-cache gcc musl-dev linux-headers		<span style=color:#75715e># 运行</span>
</span></span><span style=display:flex><span>COPY requirements.txt requirements.txt					<span style=color:#75715e># 拷贝文件</span>
</span></span><span style=display:flex><span>RUN pip install -r requirements.txt						<span style=color:#75715e># 使用pip安装</span>
</span></span><span style=display:flex><span>EXPOSE 5000												<span style=color:#75715e># 暴露端口</span>
</span></span><span style=display:flex><span>COPY . .												<span style=color:#75715e># 拷贝当前目录</span>
</span></span><span style=display:flex><span>CMD <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;flask&#34;</span>, <span style=color:#e6db74>&#34;run&#34;</span><span style=color:#f92672>]</span>									<span style=color:#75715e># 运行</span>
</span></span></code></pre></div><p>5.在Compose文件中定义服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># 以前我们需要docker run逐个运行</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 现在创建docker-compose.yml文件</span>
</span></span><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.9&#34;</span>					<span style=color:#75715e># 版本</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>services:						# 服务</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;5000:5000&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#e6db74>&#34;redis:alpine&#34;</span>
</span></span></code></pre></div><p>6.使用<code>Compose</code>构建并运行应用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker-compose up <span style=color:#75715e># docker-compose up -d 后台运行</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 我这里报错了，报错如下：</span>
</span></span><span style=display:flex><span>ERROR: Version in <span style=color:#e6db74>&#34;./docker-compose.yml&#34;</span> is unsupported. You might be seeing this error because you<span style=color:#960050;background-color:#1e0010>&#39;</span>re using the wrong Compose file version. Either specify a supported version <span style=color:#f92672>(</span>e.g <span style=color:#e6db74>&#34;2.2&#34;</span> or <span style=color:#e6db74>&#34;3.3&#34;</span><span style=color:#f92672>)</span> and place your service definitions under the <span style=color:#e6db74>`</span>services<span style=color:#e6db74>`</span> key, or omit the <span style=color:#e6db74>`</span>version<span style=color:#e6db74>`</span> key and place your service definitions at the root of the file to use version 1.
</span></span><span style=display:flex><span>For more on the Compose file format versions, see https://docs.docker.com/compose/compose-file/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 解决方案，修改docker-compose.yml文件中的版本</span>
</span></span><span style=display:flex><span>version: <span style=color:#e6db74>&#34;3.9&#34;</span>  -&gt;  version: <span style=color:#e6db74>&#34;3.3&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 项目部署过程中出现了其它错误</span>
</span></span><span style=display:flex><span>docker-compose build <span style=color:#75715e># 先build一下</span>
</span></span><span style=display:flex><span>docker-compose up <span style=color:#75715e># 成功启动</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 测试，每访问一次计数器+1</span>
</span></span><span style=display:flex><span>localhost:5000 <span style=color:#75715e># 浏览器键入</span>
</span></span><span style=display:flex><span>curl localhost:5000 <span style=color:#75715e># curl请求</span>
</span></span></code></pre></div><p>7.停止：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 在yaml文件所在目录下运行命令</span>
</span></span><span style=display:flex><span>docker-compose stop
</span></span><span style=display:flex><span>Ctrl+C
</span></span></code></pre></div><p><strong>流程：</strong></p><p>1.创建网络</p><p>2.执行<code>Docker-compose.yml</code></p><p>3.启动服务</p><p>默认规则：</p><p>自动拉取镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>Error response from daemon: This node is not a swarm manager. Use <span style=color:#e6db74>&#34;docker swarm init&#34;</span> or <span style=color:#e6db74>&#34;docker swarm join&#34;</span> to connect this node to swarm and try again.
</span></span></code></pre></div><p>**命名规则：**默认服务名 文件名_服务名_num。A B _num 副本数量。集群状态下不可能只有一个运行实例。弹性：10 HA 高可用、高并发。<code>kunectl service</code>负载均衡。</p><p>**网络规则：**使用命令<code>docker network ls</code>查看，默认名称composetest_default。项目中的内容都在同一网络，可通过域名访问。</p><p><strong>小结：</strong></p><p>1.应用，如<code>app.py</code></p><p>2.<code>Dockerfile</code>应用打包为镜像</p><p>3.<code>Docker-compose.yml</code>文件(定义整个服务、需要的环境)。完整的上线服务</p><p>4.启动<code>compose</code>项目(<code>docker-compose up</code>)</p><h2 id=yaml规则>yaml规则<a hidden class=anchor aria-hidden=true href=#yaml规则>#</a></h2><p>官方示例:<a href=https://docs.docker.com/compose/compose-file/compose-file-v3/>Compose file version 3 reference | Docker Documentation</a></p><p><code>docker-compose.yml</code>是核心。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># 只有三层</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;&#39;</span> <span style=color:#75715e># 版本</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>: <span style=color:#75715e># 服务</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>服务1</span>: <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e># 服务配置</span>
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>images</span>
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>build</span>
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>network</span>
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>...</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>服务2</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>...</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 其他配置 网络/卷/全局规则</span>
</span></span><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>configs</span>:
</span></span></code></pre></div><p><code>depends_on</code></p><p>Simple example：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.9&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>depends_on:			# 依赖于db和redis</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>db</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>db</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动顺序：web --&gt; redis --&gt; db</span>
</span></span></code></pre></div><blockquote><p>There are several things to be aware of when using <code>depends_on</code>:</p><ul><li><code>depends_on</code> does not wait for <code>db</code> and <code>redis</code> to be “ready” before starting <code>web</code> - only until they have been started. If you need to wait for a service to be ready, see <a href=https://docs.docker.com/compose/startup-order/>Controlling startup order</a> for more on this problem and strategies for solving it.</li><li>Version 3 no longer supports the <code>condition</code> form of <code>depends_on</code>.</li><li>The <code>depends_on</code> option is ignored when <a href=https://docs.docker.com/engine/reference/commandline/stack_deploy/>deploying a stack in swarm mode</a> with a version 3 Compose file.</li></ul></blockquote><p><strong>deploy</strong></p><blockquote><p>Added in <a href=https://docs.docker.com/compose/compose-file/compose-versioning/#version-3>version 3</a> file format.</p></blockquote><p>Specify configuration related to the deployment and running of services. This only takes effect when deploying to a <a href=https://docs.docker.com/engine/swarm/>swarm</a> with <a href=https://docs.docker.com/engine/reference/commandline/stack_deploy/>docker stack deploy</a>, and is ignored by <code>docker-compose up</code> and <code>docker-compose run</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.9&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis:alpine</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>deploy</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>6</span>					<span style=color:#75715e># 副本</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>placement</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>max_replicas_per_node</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>update_config</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>parallelism</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>delay</span>: <span style=color:#ae81ff>10s</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>restart_policy</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>condition</span>: <span style=color:#66d9ef>on</span>-<span style=color:#ae81ff>failure</span>
</span></span></code></pre></div><h2 id=部署wp博客>部署wp博客<a hidden class=anchor aria-hidden=true href=#部署wp博客>#</a></h2><p>官方文档部署WordPress博客:<a href=https://docs.docker.com/samples/wordpress/>Quickstart: Compose and WordPress | Docker Documentation</a></p><p>1.创建一个空文件夹，此处命名为<code>my_wordpress</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir my_wordpress
</span></span></code></pre></div><p>2.切换到对应目录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cd my_wordpress/
</span></span></code></pre></div><p>3.创建<code>docker-compose.yml</code>文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.3&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>db</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>mysql:5.7</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>db_data:/var/lib/mysql</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>MYSQL_ROOT_PASSWORD</span>: <span style=color:#ae81ff>somewordpress</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MYSQL_DATABASE</span>: <span style=color:#ae81ff>wordpress</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MYSQL_USER</span>: <span style=color:#ae81ff>wordpress</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MYSQL_PASSWORD</span>: <span style=color:#ae81ff>wordpress</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#f92672>wordpress</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>db</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>wordpress:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;8000:80&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>WORDPRESS_DB_HOST</span>: <span style=color:#ae81ff>db:3306</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>WORDPRESS_DB_USER</span>: <span style=color:#ae81ff>wordpress</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>WORDPRESS_DB_PASSWORD</span>: <span style=color:#ae81ff>wordpress</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>WORDPRESS_DB_NAME</span>: <span style=color:#ae81ff>wordpress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>db_data</span>: {}
</span></span></code></pre></div><blockquote><p><strong>Notes</strong>:</p><ul><li>The docker volume <code>db_data</code> persists any updates made by WordPress to the database. <a href=https://docs.docker.com/storage/volumes/>Learn more about docker volumes</a></li><li>WordPress Multisite works only on ports <code>80</code> and <code>443</code>.</li></ul></blockquote><p>4.构建项目</p><p>Now, run <code>docker-compose up -d</code> from your project directory.</p><p>This runs <a href=https://docs.docker.com/compose/reference/up/><code>docker-compose up</code></a> in detached mode, pulls the needed Docker images, and starts the wordpress and database containers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ docker-compose up -d
</span></span></code></pre></div><blockquote><p><strong>Note</strong>: WordPress Multisite works only on ports <code>80</code> and/or <code>443</code>. If you get an error message about binding <code>0.0.0.0</code> to port <code>80</code> or <code>443</code> (depending on which one you specified), it is likely that the port you configured for WordPress is already in use by another service.</p></blockquote><p>5.开始安装</p><p>经过第4步后，访问<code>localhost:8000</code>端口即可设置博客。</p><h2 id=实战>实战<a hidden class=anchor aria-hidden=true href=#实战>#</a></h2><p>1.编写项目微服务</p><p>2.<code>Dockefile</code>构建镜像</p><p>3.<code>docker-compose.yaml</code>编排项目</p><p>4.<code>docker-compose up</code></p><p>5.<code>docker-compose up --build</code>项目重新部署打包</p><h1 id=docker-swarm>Docker Swarm<a hidden class=anchor aria-hidden=true href=#docker-swarm>#</a></h1><p>Docker Swarm官方文档:<a href=https://docs.docker.com/engine/swarm/>Swarm mode overview | Docker Documentation</a></p><h2 id=节点如何工作>节点如何工作：<a hidden class=anchor aria-hidden=true href=#节点如何工作>#</a></h2><p>Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.</p><p>There are two types of nodes: <a href=https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/#manager-nodes><strong>managers</strong></a> and <a href=https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/#worker-nodes><strong>workers</strong></a>.</p><p><img loading=lazy src=https://docs.docker.com/engine/swarm/images/swarm-diagram.png alt="Swarm mode cluster"></p><p>If you haven’t already, read through the <a href=https://docs.docker.com/engine/swarm/>swarm mode overview</a> and <a href=https://docs.docker.com/engine/swarm/key-concepts/>key concepts</a>.</p><h2 id=管理与工作节点>管理与工作节点<a hidden class=anchor aria-hidden=true href=#管理与工作节点>#</a></h2><h3 id=管理节点>管理节点<a hidden class=anchor aria-hidden=true href=#管理节点>#</a></h3><p>Manager nodes handle cluster management tasks:</p><ul><li>maintaining cluster state</li><li>scheduling services</li><li>serving swarm mode <a href=https://docs.docker.com/engine/api/>HTTP API endpoints</a></li></ul><p>Using a <a href=https://raft.github.io/raft.pdf>Raft</a> implementation, the managers maintain a consistent internal state of the entire swarm and all the services running on it. For testing purposes it is OK to run a swarm with a single manager. If the manager in a single-manager swarm fails, your services continue to run, but you need to create a new cluster to recover.</p><p>To take advantage of swarm mode’s fault-tolerance features, Docker recommends you implement an odd number of nodes according to your organization’s high-availability requirements. When you have multiple managers you can recover from the failure of a manager node without downtime.</p><ul><li><p>A three-manager swarm tolerates a maximum loss of one manager.</p></li><li><p>A five-manager swarm tolerates a maximum simultaneous loss of two manager nodes.</p></li><li><p>An <code>N</code> manager cluster tolerates the loss of at most <code>(N-1)/2</code> managers.</p></li><li><p>Docker recommends a maximum of seven manager nodes for a swarm.</p><blockquote><p><strong>Important Note</strong>: Adding more managers does NOT mean increased scalability or higher performance. In general, the opposite is true.</p></blockquote></li></ul><h3 id=工作节点>工作节点<a hidden class=anchor aria-hidden=true href=#工作节点>#</a></h3><p>Worker nodes are also instances of Docker Engine whose sole purpose is to execute containers. Worker nodes don’t participate in the Raft distributed state, make scheduling decisions, or serve the swarm mode HTTP API.</p><p>You can create a swarm of one manager node, but you cannot have a worker node without at least one manager node. By default, all managers are also workers. In a single manager node cluster, you can run commands like <code>docker service create</code> and the scheduler places all tasks on the local Engine.</p><p>To prevent the scheduler from placing tasks on a manager node in a multi-node swarm, set the availability for the manager node to <code>Drain</code>. The scheduler gracefully stops tasks on nodes in <code>Drain</code> mode and schedules the tasks on an <code>Active</code> node. The scheduler does not assign new tasks to nodes with <code>Drain</code> availability.</p><p>Refer to the <a href=https://docs.docker.com/engine/reference/commandline/node_update/><code>docker node update</code></a> command line reference to see how to change node availability.</p><h2 id=raft>Raft<a hidden class=anchor aria-hidden=true href=#raft>#</a></h2><p>图中有一个<code>Raft Consensus Group</code>的概念，我们来查阅一下资料。</p><p><code>Raft</code>:一种新的分布式协议研究，为真实世界应用建立的协议，主要注重协议落地性和可理解性。保证大多数节点存活才可使用。</p><p>关于分布式系统的Raft算法讲解:<a href=https://www.jdon.com/artichect/raft.html>分布式系统的Raft算法 - 解道Jdon</a></p><p>Raft算法详解:<a href=https://my.oschina.net/u/3550665/blog/4367046>图解：什么是Raft算法？ - 无敌码龙的个人空间 - OSCHINA - 中文开源技术交流社区</a></p><h2 id=命令>命令<a hidden class=anchor aria-hidden=true href=#命令>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 帮助命令</span>
</span></span><span style=display:flex><span>docker swarm --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage:  docker swarm COMMAND
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Manage Swarm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Commands:
</span></span><span style=display:flex><span>  ca          Display and rotate the root CA
</span></span><span style=display:flex><span>  init        Initialize a swarm
</span></span><span style=display:flex><span>  join        Join a swarm as a node and/or manager
</span></span><span style=display:flex><span>  join-token  Manage join tokens
</span></span><span style=display:flex><span>  leave       Leave the swarm
</span></span><span style=display:flex><span>  unlock      Unlock swarm
</span></span><span style=display:flex><span>  unlock-key  Manage the unlock key
</span></span><span style=display:flex><span>  update      Update the swarm
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>docker swarm init			<span style=color:#75715e># 初始化节点</span>
</span></span><span style=display:flex><span>docker swarm join			<span style=color:#75715e># 加入节点</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取令牌</span>
</span></span><span style=display:flex><span>docker swarm join-token manager
</span></span><span style=display:flex><span>docker swarm join-token worker
</span></span><span style=display:flex><span>docker node ls 				<span style=color:#75715e># 查看节点</span>
</span></span></code></pre></div><h2 id=具体使用>具体使用<a hidden class=anchor aria-hidden=true href=#具体使用>#</a></h2><p>服务无感升级为灰度发布(也称金丝雀发布)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run														<span style=color:#75715e># 容器启动，不具有扩缩容功能</span>
</span></span><span style=display:flex><span>docker service 服务											   <span style=color:#75715e># 能实现扩缩容及滚动更新</span>
</span></span><span style=display:flex><span>docker service create -p 8888:80 --name my-nginx nginx
</span></span><span style=display:flex><span><span style=color:#75715e># 查看服务</span>
</span></span><span style=display:flex><span>docker service ps my-nginx
</span></span><span style=display:flex><span>docker service ls
</span></span><span style=display:flex><span>docker service inspect my-nginx
</span></span><span style=display:flex><span><span style=color:#75715e># 创建副本</span>
</span></span><span style=display:flex><span>docker service update --replicas <span style=color:#ae81ff>3</span> my-nginx
</span></span><span style=display:flex><span>docker service update --replicas <span style=color:#ae81ff>1</span> my-nginx 				    <span style=color:#75715e># 更新为1个服务</span>
</span></span><span style=display:flex><span>docker service scale my-nginx<span style=color:#f92672>=</span>5									<span style=color:#75715e># 动态扩缩容，与update效果相同</span>
</span></span><span style=display:flex><span>docker service rm my-nginx
</span></span></code></pre></div><h2 id=概念总结>概念总结<a hidden class=anchor aria-hidden=true href=#概念总结>#</a></h2><h3 id=swarm>Swarm<a hidden class=anchor aria-hidden=true href=#swarm>#</a></h3><p>集群的管理和编号。<code>docker</code>可以初始化一个<code>swarm</code>集群，其它节点可以加入。(<code>manager、worker</code>)</p><h3 id=node>Node<a hidden class=anchor aria-hidden=true href=#node>#</a></h3><p>就是一个<code>docker</code>节点，多个节点组成一个网络集群。</p><h3 id=service>Service<a hidden class=anchor aria-hidden=true href=#service>#</a></h3><p>任务，可以在<code>manager</code>或<code>worker</code>来运行。用户访问的其实就是<code>service</code>，这是集群的核心。</p><h3 id=task>Task<a hidden class=anchor aria-hidden=true href=#task>#</a></h3><p>容器内命令，细节任务。</p><h3 id=调整service运行方式>调整service运行方式<a hidden class=anchor aria-hidden=true href=#调整service运行方式>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker service create --mode replicated --name my-centos centos			<span style=color:#75715e># 仅在副本运行</span>
</span></span><span style=display:flex><span>docker service create --mode global --name haha alpine ping baidu.com	<span style=color:#75715e># 全局运行</span>
</span></span></code></pre></div><h3 id=拓展>拓展<a hidden class=anchor aria-hidden=true href=#拓展>#</a></h3><p>网络模式：&ldquo;PublishMode&rdquo;:&ldquo;ingress&rdquo;</p><p>Swarm:</p><p><code>Overlay</code>:网络变成一个整体</p><p><code>ingress</code>:具有负载均衡功能的特殊<code>Overlay</code>网络，</p><h1 id=docker-stack>Docker Stack<a hidden class=anchor aria-hidden=true href=#docker-stack>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker-compose			<span style=color:#75715e># 单机部署项目</span>
</span></span><span style=display:flex><span>docker-compose up -d wordpress.yaml 
</span></span><span style=display:flex><span>docker stack			<span style=color:#75715e># 集群部署</span>
</span></span><span style=display:flex><span>docker stack deploy wordpress.yaml
</span></span></code></pre></div><h1 id=docker-secret>Docker Secret<a hidden class=anchor aria-hidden=true href=#docker-secret>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Commands:
</span></span><span style=display:flex><span>  create      Create a secret from a file or STDIN as content
</span></span><span style=display:flex><span>  inspect     Display detailed information on one or more secrets
</span></span><span style=display:flex><span>  ls          List secrets
</span></span><span style=display:flex><span>  rm          Remove one or more secrets
</span></span></code></pre></div><h1 id=docker-config>Docker Config<a hidden class=anchor aria-hidden=true href=#docker-config>#</a></h1><pre tabindex=0><code>Commands:
  create      Create a config from a file or STDIN
  inspect     Display detailed information on one or more configs
  ls          List configs
  rm          Remove one or more configs
</code></pre><blockquote><p>文章许可：本文采用<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>CC BY-NC-SA 4.0</a>许可协议，转载请注明出处。</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://oopsdc.com/tags/daily/>Daily</a></li></ul><nav class=paginav><a class=prev href=https://oopsdc.com/post/%E7%BD%91%E7%AB%99%E9%95%9C%E5%83%8F%E5%85%8B%E9%9A%86/><span class=title>« Prev</span><br><span>网站镜像克隆</span></a>
<a class=next href=https://oopsdc.com/post/golang/><span class=title>Next »</span><br><span>Golang</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>Comments</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.6/twikoo.all.min.js></script>
<script>twikoo.init({envId:"https://twikoo-oopsdc.vercel.app/",el:"#tcomment",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><div><span id=busuanzi_container_site_pv>Views: <span id=busuanzi_value_site_pv></span></span>
&nbsp;
<span id=busuanzi_container_site_uv>Visitors: <span id=busuanzi_value_site_uv></span></span></div><span>&copy; 2022 <a href=https://oopsdc.com/>0opsdc</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>